     1                    	;
     2                    	; cb_emu_8080
     3                    	;
     4                    	
     5                    	;**************************************************************
     6                    	;*
     7                    	;*             C P / M   version   2 . 2
     8                    	;*
     9                    	;*   Reconstructed from memory image on February 27, 1981
    10                    	;*
    11                    	;*                by Clark A. Calkins
    12                    	;*
    13                    	;**************************************************************
    14                    	;
    15                    	;   Set memory limit here. This is the amount of contigeous
    16                    	; ram starting from 0000. CP/M will reside at the end of this space.
    17                    	;
    18                    	;cb_emu_8080 - Was : MEM	EQU	62	;for a 62k system (TS802 TEST - WORKS OK).
    19      00 40         	MEM	EQU	64	;for a 64K cb_emu_8080 system.
    20                    	;
    21      00 03         	IOBYTE	EQU	3	;i/o definition byte.
    22      00 04         	TDRIVE	EQU	4	;current drive name and user number.
    23      00 05         	ENTRY	EQU	5	;entry point for the cp/m bdos.
    24      00 5C         	TFCB	EQU	5CH	;default file control block.
    25      00 80         	TBUFF	EQU	80H	;i/o buffer and command line storage.
    26      01 00         	TBASE	EQU	100H	;transiant program storage area.
    27                    	;
    28                    	;   Set control character equates.
    29                    	;
    30      00 03         	CNTRLC	EQU	3	;control-c
    31      00 05         	CNTRLE	EQU	05H	;control-e
    32      00 08         	BS	EQU	08H	;backspace
    33      00 09         	TAB	EQU	09H	;tab
    34      00 0A         	LF	EQU	0AH	;line feed
    35      00 0C         	FF	EQU	0CH	;form feed
    36      00 0D         	CR	EQU	0DH	;carriage return
    37      00 10         	CNTRLP	EQU	10H	;control-p
    38      00 12         	CNTRLR	EQU	12H	;control-r
    39      00 13         	CNTRLS	EQU	13H	;control-s
    40      00 15         	CNTRLU	EQU	15H	;control-u
    41      00 18         	CNTRLX	EQU	18H	;control-x
    42      00 1A         	CNTRLZ	EQU	1AH	;control-z (end-of-file mark)
    43      00 7F         	DEL	EQU	7FH	;rubout
    44                    	;
    45                    	;   Set origin for CP/M
    46                    	;
    47      E4 00         		ORG	(MEM-7)*1024
    48                    	;
    49 E400 C3 5C E7      	CBASE	JMP	COMMAND	;execute command processor (ccp).
    50 E403 C3 58 E7      		JMP	CLEARBUF	;entry to empty input buffer before starting ccp.
    51                    	
    52                    	;
    53                    	;   Standard cp/m ccp input buffer. Format is (max length),
    54                    	; (actual length), (char #1), (char #2), (char #3), etc.
    55                    	;
    56 E406               	INBUFF	DB	127	;length of input buffer.
            7F 
    57 E407               		DB	0	;current length of contents.
            00 
    58 E408               		DB	'Copyright'
            43 6F 70 79 
            72 69 67 68 
            74 
    59 E411               		DB	' 1979 (c) by Digital Research      '
            20 31 39 37 
            39 20 28 63 
            29 20 62 79 
            20 44 69 67 
            69 74 61 6C 
            20 52 65 73 
            65 61 72 63 
            68 20 20 20 
            20 20 20 
    60 E434               		DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 
    61 E44B               		DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 
    62 E462               		DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 
    63 E479               		DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 
    64 E488               	INPOINT	DW	INBUFF+2;input line pointer
            08 E4 
    65 E48A               	NAMEPNT	DW	0	;input line pointer used for error message. Points to
            00 00 
    66                    	;			;start of name in error.
    67                    	;
    68                    	;   Routine to print (A) on the console. All registers used.
    69                    	;
    70 E48C 5F            	PRINT	MOV	E,A	;setup bdos call.
    71 E48D 0E 02         		MVI	C,2
    72 E48F C3 05 00      		JMP	ENTRY
    73                    	;
    74                    	;   Routine to print (A) on the console and to save (BC).
    75                    	;
    76 E492 C5            	PRINTB	PUSH	B
    77 E493 CD 8C E4      		CALL	PRINT
    78 E496 C1            		POP	B
    79 E497 C9            		RET
    80                    	;
    81                    	;   Routine to send a carriage return, line feed combination
    82                    	; to the console.
    83                    	;
    84 E498 3E 0D         	CRLF	MVI	A,CR
    85 E49A CD 92 E4      		CALL	PRINTB
    86 E49D 3E 0A         		MVI	A,LF
    87 E49F C3 92 E4      		JMP	PRINTB
    88                    	;
    89                    	;   Routine to send one space to the console and save (BC).
    90                    	;
    91 E4A2 3E 20         	SPACE	MVI	A,' '
    92 E4A4 C3 92 E4      		JMP	PRINTB
    93                    	;
    94                    	;   Routine to print character string pointed to be (BC) on the
    95                    	; console. It must terminate with a null byte.
    96                    	;
    97 E4A7 C5            	PLINE	PUSH	B
    98 E4A8 CD 98 E4      		CALL	CRLF
    99 E4AB E1            		POP	H
   100 E4AC 7E            	PLINE2	MOV	A,M
   101 E4AD B7            		ORA	A
   102 E4AE C8            		RZ
   103 E4AF 23            		INX	H
   104 E4B0 E5            		PUSH	H
   105 E4B1 CD 8C E4      		CALL	PRINT
   106 E4B4 E1            		POP	H
   107 E4B5 C3 AC E4      		JMP	PLINE2
   108                    	;
   109                    	;   Routine to reset the disk system.
   110                    	;
   111 E4B8 0E 0D         	RESDSK	MVI	C,13
   112 E4BA C3 05 00      		JMP	ENTRY
   113                    	;
   114                    	;   Routine to select disk (A).
   115                    	;
   116 E4BD 5F            	DSKSEL	MOV	E,A
   117 E4BE 0E 0E         		MVI	C,14
   118 E4C0 C3 05 00      		JMP	ENTRY
   119                    	;
   120                    	;   Routine to call bdos and save the return code. The zero
   121                    	; flag is set on a return of 0ffh.
   122                    	;
   123 E4C3 CD 05 00      	ENTRY1	CALL	ENTRY
   124 E4C6 32 EE EB      		STA	RTNCODE	;save return code.
   125 E4C9 3C            		INR	A	;set zero if 0ffh returned.
   126 E4CA C9            		RET
   127                    	;
   128                    	;   Routine to open a file. (DE) must point to the FCB.
   129                    	;
   130 E4CB 0E 0F         	OPEN	MVI	C,15
   131 E4CD C3 C3 E4      		JMP	ENTRY1
   132                    	;
   133                    	;   Routine to open file at (FCB).
   134                    	;
   135 E4D0 AF            	OPENFCB	XRA	A	;clear the record number byte at fcb+32
   136 E4D1 32 ED EB      		STA	FCB+32
   137 E4D4 11 CD EB      		LXI	D,FCB
   138 E4D7 C3 CB E4      		JMP	OPEN
   139                    	;
   140                    	;   Routine to close a file. (DE) points to FCB.
   141                    	;
   142 E4DA 0E 10         	CLOSE	MVI	C,16
   143 E4DC C3 C3 E4      		JMP	ENTRY1
   144                    	;
   145                    	;   Routine to search for the first file with ambigueous name
   146                    	; (DE).
   147                    	;
   148 E4DF 0E 11         	SRCHFST	MVI	C,17
   149 E4E1 C3 C3 E4      		JMP	ENTRY1
   150                    	;
   151                    	;   Search for the next ambigeous file name.
   152                    	;
   153 E4E4 0E 12         	SRCHNXT	MVI	C,18
   154 E4E6 C3 C3 E4      		JMP	ENTRY1
   155                    	;
   156                    	;   Search for file at (FCB).
   157                    	;
   158 E4E9 11 CD EB      	SRCHFCB	LXI	D,FCB
   159 E4EC C3 DF E4      		JMP	SRCHFST
   160                    	;
   161                    	;   Routine to delete a file pointed to by (DE).
   162                    	;
   163 E4EF 0E 13         	DELETE	MVI	C,19
   164 E4F1 C3 05 00      		JMP	ENTRY
   165                    	;
   166                    	;   Routine to call the bdos and set the zero flag if a zero
   167                    	; status is returned.
   168                    	;
   169 E4F4 CD 05 00      	ENTRY2	CALL	ENTRY
   170 E4F7 B7            		ORA	A	;set zero flag if appropriate.
   171 E4F8 C9            		RET
   172                    	;
   173                    	;   Routine to read the next record from a sequential file.
   174                    	; (DE) points to the FCB.
   175                    	;
   176 E4F9 0E 14         	RDREC	MVI	C,20
   177 E4FB C3 F4 E4      		JMP	ENTRY2
   178                    	;
   179                    	;   Routine to read file at (FCB).
   180                    	;
   181 E4FE 11 CD EB      	READFCB	LXI	D,FCB
   182 E501 C3 F9 E4      		JMP	RDREC
   183                    	;
   184                    	;   Routine to write the next record of a sequential file.
   185                    	; (DE) points to the FCB.
   186                    	;
   187 E504 0E 15         	WRTREC	MVI	C,21
   188 E506 C3 F4 E4      		JMP	ENTRY2
   189                    	;
   190                    	;   Routine to create the file pointed to by (DE).
   191                    	;
   192 E509 0E 16         	CREATE	MVI	C,22
   193 E50B C3 C3 E4      		JMP	ENTRY1
   194                    	;
   195                    	;   Routine to rename the file pointed to by (DE). Note that
   196                    	; the new name starts at (DE+16).
   197                    	;
   198 E50E 0E 17         	RENAM	MVI	C,23
   199 E510 C3 05 00      		JMP	ENTRY
   200                    	;
   201                    	;   Get the current user code.
   202                    	;
   203 E513 1E FF         	GETUSR	MVI	E,0FFH
   204                    	;
   205                    	;   Routne to get or set the current user code.
   206                    	; If (E) is FF then this is a GET, else it is a SET.
   207                    	;
   208 E515 0E 20         	GETSETUC:MVI	C,32
   209 E517 C3 05 00      		JMP	ENTRY
   210                    	;
   211                    	;   Routine to set the current drive byte at (TDRIVE).
   212                    	;
   213 E51A CD 13 E5      	SETCDRV	CALL	GETUSR	;get user number
   214 E51D 87            		ADD	A	;and shift into the upper 4 bits.
   215 E51E 87            		ADD	A
   216 E51F 87            		ADD	A
   217 E520 87            		ADD	A
   218 E521 21 EF EB      		LXI	H,CDRIVE;now add in the current drive number.
   219 E524 B6            		ORA	M
   220 E525 32 04 00      		STA	TDRIVE	;and save.
   221 E528 C9            		RET
   222                    	;
   223                    	;   Move currently active drive down to (TDRIVE).
   224                    	;
   225 E529 3A EF EB      	MOVECD	LDA	CDRIVE
   226 E52C 32 04 00      		STA	TDRIVE
   227 E52F C9            		RET
   228                    	;
   229                    	;   Routine to convert (A) into upper case ascii. Only letters
   230                    	; are affected.
   231                    	;
   232 E530 FE 61         	UPPER	CPI	'a'	;check for letters in the range of 'a' to 'z'.
   233 E532 D8            		RC
   234 E533 FE 7B         		CPI	'{'
   235 E535 D0            		RNC
   236 E536 E6 5F         		ANI	5FH	;convert it if found.
   237 E538 C9            		RET
   238                    	;
   239                    	;   Routine to get a line of input. We must check to see if the
   240                    	; user is in (BATCH) mode. If so, then read the input from file
   241                    	; ($$$.SUB). At the end, reset to console input.
   242                    	;
   243 E539 3A AB EB      	GETINP	LDA	BATCH	;if =0, then use console input.
   244 E53C B7            		ORA	A
   245 E53D CA 96 E5      		JZ	GETINP1
   246                    	;
   247                    	;   Use the submit file ($$$.sub) which is prepared by a
   248                    	; SUBMIT run. It must be on drive (A) and it will be deleted
   249                    	; if and error occures (like eof).
   250                    	;
   251 E540 3A EF EB      		LDA	CDRIVE	;select drive 0 if need be.
   252 E543 B7            		ORA	A
   253 E544 3E 00         		MVI	A,0	;always use drive A for submit.
   254 E546 C4 BD E4      		CNZ	DSKSEL	;select it if required.
   255 E549 11 AC EB      		LXI	D,BATCHFCB
   256 E54C CD CB E4      		CALL	OPEN	;look for it.
   257 E54F CA 96 E5      		JZ	GETINP1	;if not there, use normal input.
   258 E552 3A BB EB      		LDA	BATCHFCB+15;get last record number+1.
   259 E555 3D            		DCR	A
   260 E556 32 CC EB      		STA	BATCHFCB+32
   261 E559 11 AC EB      		LXI	D,BATCHFCB
   262 E55C CD F9 E4      		CALL	RDREC	;read last record.
   263 E55F C2 96 E5      		JNZ	GETINP1	;quit on end of file.
   264                    	;
   265                    	;   Move this record into input buffer.
   266                    	;
   267 E562 11 07 E4      		LXI	D,INBUFF+1
   268 E565 21 80 00      		LXI	H,TBUFF	;data was read into buffer here.
   269 E568 06 80         		MVI	B,128	;all 128 characters may be used.
   270 E56A CD 42 E8      		CALL	HL2DE	;(HL) to (DE), (B) bytes.
   271 E56D 21 BA EB      		LXI	H,BATCHFCB+14
   272 E570 36 00         		MVI	M,0	;zero out the 's2' byte.
   273 E572 23            		INX	H	;and decrement the record count.
   274 E573 35            		DCR	M
   275 E574 11 AC EB      		LXI	D,BATCHFCB;close the batch file now.
   276 E577 CD DA E4      		CALL	CLOSE
   277 E57A CA 96 E5      		JZ	GETINP1	;quit on an error.
   278 E57D 3A EF EB      		LDA	CDRIVE	;re-select previous drive if need be.
   279 E580 B7            		ORA	A
   280 E581 C4 BD E4      		CNZ	DSKSEL	;don't do needless selects.
   281                    	;
   282                    	;   Print line just read on console.
   283                    	;
   284 E584 21 08 E4      		LXI	H,INBUFF+2
   285 E587 CD AC E4      		CALL	PLINE2
   286 E58A CD C2 E5      		CALL	CHKCON	;check console, quit on a key.
   287 E58D CA A7 E5      		JZ	GETINP2	;jump if no key is pressed.
   288                    	;
   289                    	;   Terminate the submit job on any keyboard input. Delete this
   290                    	; file such that it is not re-started and jump to normal keyboard
   291                    	; input section.
   292                    	;
   293 E590 CD DD E5      		CALL	DELBATCH;delete the batch file.
   294 E593 C3 82 E7      		JMP	CMMND1	;and restart command input.
   295                    	;
   296                    	;   Get here for normal keyboard input. Delete the submit file
   297                    	; incase there was one.
   298                    	;
   299 E596 CD DD E5      	GETINP1	CALL	DELBATCH;delete file ($$$.sub).
   300 E599 CD 1A E5      		CALL	SETCDRV	;reset active disk.
   301 E59C 0E 0A         		MVI	C,10	;get line from console device.
   302 E59E 11 06 E4      		LXI	D,INBUFF
   303 E5A1 CD 05 00      		CALL	ENTRY
   304 E5A4 CD 29 E5      		CALL	MOVECD	;reset current drive (again).
   305                    	;
   306                    	;   Convert input line to upper case.
   307                    	;
   308 E5A7 21 07 E4      	GETINP2	LXI	H,INBUFF+1
   309 E5AA 46            		MOV	B,M	;(B)=character counter.
   310 E5AB 23            	GETINP3	INX	H
   311 E5AC 78            		MOV	A,B	;end of the line?
   312 E5AD B7            		ORA	A
   313 E5AE CA BA E5      		JZ	GETINP4
   314 E5B1 7E            		MOV	A,M	;convert to upper case.
   315 E5B2 CD 30 E5      		CALL	UPPER
   316 E5B5 77            		MOV	M,A
   317 E5B6 05            		DCR	B	;adjust character count.
   318 E5B7 C3 AB E5      		JMP	GETINP3
   319 E5BA 77            	GETINP4	MOV	M,A	;add trailing null.
   320 E5BB 21 08 E4      		LXI	H,INBUFF+2
   321 E5BE 22 88 E4      		SHLD	INPOINT	;reset input line pointer.
   322 E5C1 C9            		RET
   323                    	;
   324                    	;   Routine to check the console for a key pressed. The zero
   325                    	; flag is set is none, else the character is returned in (A).
   326                    	;
   327 E5C2 0E 0B         	CHKCON	MVI	C,11	;check console.
   328 E5C4 CD 05 00      		CALL	ENTRY
   329 E5C7 B7            		ORA	A
   330 E5C8 C8            		RZ		;return if nothing.
   331 E5C9 0E 01         		MVI	C,1	;else get character.
   332 E5CB CD 05 00      		CALL	ENTRY
   333 E5CE B7            		ORA	A	;clear zero flag and return.
   334 E5CF C9            		RET
   335                    	;
   336                    	;   Routine to get the currently active drive number.
   337                    	;
   338 E5D0 0E 19         	GETDSK	MVI	C,25
   339 E5D2 C3 05 00      		JMP	ENTRY
   340                    	;
   341                    	;   Set the stabdard dma address.
   342                    	;
   343 E5D5 11 80 00      	STDDMA	LXI	D,TBUFF
   344                    	;
   345                    	;   Routine to set the dma address to (DE).
   346                    	;
   347 E5D8 0E 1A         	DMASET	MVI	C,26
   348 E5DA C3 05 00      		JMP	ENTRY
   349                    	;
   350                    	;  Delete the batch file created by SUBMIT.
   351                    	;
   352 E5DD 21 AB EB      	DELBATCH:LXI	H,BATCH	;is batch active?
   353 E5E0 7E            		MOV	A,M
   354 E5E1 B7            		ORA	A
   355 E5E2 C8            		RZ
   356 E5E3 36 00         		MVI	M,0	;yes, de-activate it.
   357 E5E5 AF            		XRA	A
   358 E5E6 CD BD E4      		CALL	DSKSEL	;select drive 0 for sure.
   359 E5E9 11 AC EB      		LXI	D,BATCHFCB;and delete this file.
   360 E5EC CD EF E4      		CALL	DELETE
   361 E5EF 3A EF EB      		LDA	CDRIVE	;reset current drive.
   362 E5F2 C3 BD E4      		JMP	DSKSEL
   363                    	;
   364                    	;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
   365                    	; the same or we halt....
   366                    	;
   367 E5F5 11 28 E7      	VERIFY	LXI	D,PATTRN1;these are the serial number bytes.
   368 E5F8 21 00 EC      		LXI	H,PATTRN2;ditto, but how could they be different?
   369 E5FB 06 06         		MVI	B,6	;6 bytes each.
   370 E5FD 1A            	VERIFY1	LDAX	D
   371 E5FE BE            		CMP	M
   372 E5FF C2 CF E7      		JNZ	HALT	;jump to halt routine.
   373 E602 13            		INX	D
   374 E603 23            		INX	H
   375 E604 05            		DCR	B
   376 E605 C2 FD E5      		JNZ	VERIFY1
   377 E608 C9            		RET
   378                    	;
   379                    	;   Print back file name with a '?' to indicate a syntax error.
   380                    	;
   381 E609 CD 98 E4      	SYNERR	CALL	CRLF	;end current line.
   382 E60C 2A 8A E4      		LHLD	NAMEPNT	;this points to name in error.
   383 E60F 7E            	SYNERR1	MOV	A,M	;print it until a space or null is found.
   384 E610 FE 20         		CPI	' '
   385 E612 CA 22 E6      		JZ	SYNERR2
   386 E615 B7            		ORA	A
   387 E616 CA 22 E6      		JZ	SYNERR2
   388 E619 E5            		PUSH	H
   389 E61A CD 8C E4      		CALL	PRINT
   390 E61D E1            		POP	H
   391 E61E 23            		INX	H
   392 E61F C3 0F E6      		JMP	SYNERR1
   393 E622 3E 3F         	SYNERR2	MVI	A,'?'	;add trailing '?'.
   394 E624 CD 8C E4      		CALL	PRINT
   395 E627 CD 98 E4      		CALL	CRLF
   396 E62A CD DD E5      		CALL	DELBATCH;delete any batch file.
   397 E62D C3 82 E7      		JMP	CMMND1	;and restart from console input.
   398                    	;
   399                    	;   Check character at (DE) for legal command input. Note that the
   400                    	; zero flag is set if the character is a delimiter.
   401                    	;
   402 E630 1A            	CHECK	LDAX	D
   403 E631 B7            		ORA	A
   404 E632 C8            		RZ
   405 E633 FE 20         		CPI	' '	;control characters are not legal here.
   406 E635 DA 09 E6      		JC	SYNERR
   407 E638 C8            		RZ		;check for valid delimiter.
   408 E639 FE 3D         		CPI	'='
   409 E63B C8            		RZ
   410 E63C FE 5F         		CPI	'_'
   411 E63E C8            		RZ
   412 E63F FE 2E         		CPI	'.'
   413 E641 C8            		RZ
   414 E642 FE 3A         		CPI	':'
   415 E644 C8            		RZ
   416 E645 FE 3B         		CPI	';'
   417 E647 C8            		RZ
   418 E648 FE 3C         		CPI	'<'
   419 E64A C8            		RZ
   420 E64B FE 3E         		CPI	'>'
   421 E64D C8            		RZ
   422 E64E C9            		RET
   423                    	;
   424                    	;   Get the next non-blank character from (DE).
   425                    	;
   426 E64F 1A            	NONBLANK:LDAX	D
   427 E650 B7            		ORA	A	;string ends with a null.
   428 E651 C8            		RZ
   429 E652 FE 20         		CPI	' '
   430 E654 C0            		RNZ
   431 E655 13            		INX	D
   432 E656 C3 4F E6      		JMP	NONBLANK
   433                    	;
   434                    	;   Add (HL)=(HL)+(A)
   435                    	;
   436 E659 85            	ADDHL	ADD	L
   437 E65A 6F            		MOV	L,A
   438 E65B D0            		RNC	;take care of any carry.
   439 E65C 24            		INR	H
   440 E65D C9            		RET
   441                    	;
   442                    	;   Convert the first name in (FCB).
   443                    	;
   444 E65E 3E 00         	CONVFST	MVI	A,0
   445                    	;
   446                    	;   Format a file name (convert * to '?', etc.). On return,
   447                    	; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
   448                    	; the position within the fcb for the name (either 0 or 16).
   449                    	;
   450 E660 21 CD EB      	CONVERT	LXI	H,FCB
   451 E663 CD 59 E6      		CALL	ADDHL
   452 E666 E5            		PUSH	H
   453 E667 E5            		PUSH	H
   454 E668 AF            		XRA	A
   455 E669 32 F0 EB      		STA	CHGDRV	;initialize drive change flag.
   456 E66C 2A 88 E4      		LHLD	INPOINT	;set (HL) as pointer into input line.
   457 E66F EB            		XCHG
   458 E670 CD 4F E6      		CALL	NONBLANK;get next non-blank character.
   459 E673 EB            		XCHG
   460 E674 22 8A E4      		SHLD	NAMEPNT	;save pointer here for any error message.
   461 E677 EB            		XCHG
   462 E678 E1            		POP	H
   463 E679 1A            		LDAX	D	;get first character.
   464 E67A B7            		ORA	A
   465 E67B CA 89 E6      		JZ	CONVRT1
   466 E67E DE 40         		SBI	'A'-1	;might be a drive name, convert to binary.
   467 E680 47            		MOV	B,A	;and save.
   468 E681 13            		INX	D	;check next character for a ':'.
   469 E682 1A            		LDAX	D
   470 E683 FE 3A         		CPI	':'
   471 E685 CA 90 E6      		JZ	CONVRT2
   472 E688 1B            		DCX	D	;nope, move pointer back to the start of the line.
   473 E689 3A EF EB      	CONVRT1	LDA	CDRIVE
   474 E68C 77            		MOV	M,A
   475 E68D C3 96 E6      		JMP	CONVRT3
   476 E690 78            	CONVRT2	MOV	A,B
   477 E691 32 F0 EB      		STA	CHGDRV	;set change in drives flag.
   478 E694 70            		MOV	M,B
   479 E695 13            		INX	D
   480                    	;
   481                    	;   Convert the basic file name.
   482                    	;
   483 E696 06 08         	CONVRT3	MVI	B,08H
   484 E698 CD 30 E6      	CONVRT4	CALL	CHECK
   485 E69B CA B9 E6      		JZ	CONVRT8
   486 E69E 23            		INX	H
   487 E69F FE 2A         		CPI	'*'	;note that an '*' will fill the remaining
   488 E6A1 C2 A9 E6      		JNZ	CONVRT5	;field with '?'.
   489 E6A4 36 3F         		MVI	M,'?'
   490 E6A6 C3 AB E6      		JMP	CONVRT6
   491 E6A9 77            	CONVRT5	MOV	M,A
   492 E6AA 13            		INX	D
   493 E6AB 05            	CONVRT6	DCR	B
   494 E6AC C2 98 E6      		JNZ	CONVRT4
   495 E6AF CD 30 E6      	CONVRT7	CALL	CHECK	;get next delimiter.
   496 E6B2 CA C0 E6      		JZ	GETEXT
   497 E6B5 13            		INX	D
   498 E6B6 C3 AF E6      		JMP	CONVRT7
   499 E6B9 23            	CONVRT8	INX	H	;blank fill the file name.
   500 E6BA 36 20         		MVI	M,' '
   501 E6BC 05            		DCR	B
   502 E6BD C2 B9 E6      		JNZ	CONVRT8
   503                    	;
   504                    	;   Get the extension and convert it.
   505                    	;
   506 E6C0 06 03         	GETEXT	MVI	B,03H
   507 E6C2 FE 2E         		CPI	'.'
   508 E6C4 C2 E9 E6      		JNZ	GETEXT5
   509 E6C7 13            		INX	D
   510 E6C8 CD 30 E6      	GETEXT1	CALL	CHECK
   511 E6CB CA E9 E6      		JZ	GETEXT5
   512 E6CE 23            		INX	H
   513 E6CF FE 2A         		CPI	'*'
   514 E6D1 C2 D9 E6      		JNZ	GETEXT2
   515 E6D4 36 3F         		MVI	M,'?'
   516 E6D6 C3 DB E6      		JMP	GETEXT3
   517 E6D9 77            	GETEXT2	MOV	M,A
   518 E6DA 13            		INX	D
   519 E6DB 05            	GETEXT3	DCR	B
   520 E6DC C2 C8 E6      		JNZ	GETEXT1
   521 E6DF CD 30 E6      	GETEXT4	CALL	CHECK
   522 E6E2 CA F0 E6      		JZ	GETEXT6
   523 E6E5 13            		INX	D
   524 E6E6 C3 DF E6      		JMP	GETEXT4
   525 E6E9 23            	GETEXT5	INX	H
   526 E6EA 36 20         		MVI	M,' '
   527 E6EC 05            		DCR	B
   528 E6ED C2 E9 E6      		JNZ	GETEXT5
   529 E6F0 06 03         	GETEXT6	MVI	B,3
   530 E6F2 23            	GETEXT7	INX	H
   531 E6F3 36 00         		MVI	M,0
   532 E6F5 05            		DCR	B
   533 E6F6 C2 F2 E6      		JNZ	GETEXT7
   534 E6F9 EB            		XCHG
   535 E6FA 22 88 E4      		SHLD	INPOINT	;save input line pointer.
   536 E6FD E1            		POP	H
   537                    	;
   538                    	;   Check to see if this is an ambigeous file name specification.
   539                    	; Set the (A) register to non zero if it is.
   540                    	;
   541 E6FE 01 0B 00      		LXI	B,11	;set name length.
   542 E701 23            	GETEXT8	INX	H
   543 E702 7E            		MOV	A,M
   544 E703 FE 3F         		CPI	'?'	;any question marks?
   545 E705 C2 09 E7      		JNZ	GETEXT9
   546 E708 04            		INR	B	;count them.
   547 E709 0D            	GETEXT9	DCR	C
   548 E70A C2 01 E7      		JNZ	GETEXT8
   549 E70D 78            		MOV	A,B
   550 E70E B7            		ORA	A
   551 E70F C9            		RET
   552                    	;
   553                    	;   CP/M command table. Note commands can be either 3 or 4 characters long.
   554                    	;
   555      00 06         	NUMCMDS	EQU	6	;number of commands
   556 E710               	CMDTBL	DB	'DIR '
            44 49 52 20 
   557 E714               		DB	'ERA '
            45 52 41 20 
   558 E718               		DB	'TYPE'
            54 59 50 45 
   559 E71C               		DB	'SAVE'
            53 41 56 45 
   560 E720               		DB	'REN '
            52 45 4E 20 
   561 E724               		DB	'USER'
            55 53 45 52 
   562                    	;
   563                    	;   The following six bytes must agree with those at (PATTRN2)
   564                    	; or cp/m will HALT. Why?
   565                    	;
   566 E728               	PATTRN1	DB	0,22,0,0,0,0;(* serial number bytes *).
            00 16 00 00 
            00 00 
   567                    	;
   568                    	;   Search the command table for a match with what has just
   569                    	; been entered. If a match is found, then we jump to the
   570                    	; proper section. Else jump to (UNKNOWN).
   571                    	; On return, the (C) register is set to the command number
   572                    	; that matched (or NUMCMDS+1 if no match).
   573                    	;
   574 E72E 21 10 E7      	SEARCH	LXI	H,CMDTBL
   575 E731 0E 00         		MVI	C,0
   576 E733 79            	SEARCH1	MOV	A,C
   577 E734 FE 06         		CPI	NUMCMDS	;this commands exists.
   578 E736 D0            		RNC
   579 E737 11 CE EB      		LXI	D,FCB+1	;check this one.
   580 E73A 06 04         		MVI	B,4	;max command length.
   581 E73C 1A            	SEARCH2	LDAX	D
   582 E73D BE            		CMP	M
   583 E73E C2 4F E7      		JNZ	SEARCH3	;not a match.
   584 E741 13            		INX	D
   585 E742 23            		INX	H
   586 E743 05            		DCR	B
   587 E744 C2 3C E7      		JNZ	SEARCH2
   588 E747 1A            		LDAX	D	;allow a 3 character command to match.
   589 E748 FE 20         		CPI	' '
   590 E74A C2 54 E7      		JNZ	SEARCH4
   591 E74D 79            		MOV	A,C	;set return register for this command.
   592 E74E C9            		RET
   593 E74F 23            	SEARCH3	INX	H
   594 E750 05            		DCR	B
   595 E751 C2 4F E7      		JNZ	SEARCH3
   596 E754 0C            	SEARCH4	INR	C
   597 E755 C3 33 E7      		JMP	SEARCH1
   598                    	;
   599                    	;   Set the input buffer to empty and then start the command
   600                    	; processor (ccp).
   601                    	;
   602 E758 AF            	CLEARBUF:XRA	A
   603 E759 32 07 E4      		STA	INBUFF+1;second byte is actual length.
   604                    	;
   605                    	;**************************************************************
   606                    	;*
   607                    	;*
   608                    	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
   609                    	;*
   610                    	;**************************************************************
   611                    	;*
   612 E75C 31 AB EB      	COMMAND	LXI	SP,CCPSTACK;setup stack area.
   613 E75F C5            		PUSH	B	;note that (C) should be equal to:
   614 E760 79            		MOV	A,C	;(uuuudddd) where 'uuuu' is the user number
   615 E761 1F            		RAR		;and 'dddd' is the drive number.
   616 E762 1F            		RAR
   617 E763 1F            		RAR
   618 E764 1F            		RAR
   619 E765 E6 0F         		ANI	0FH	;isolate the user number.
   620 E767 5F            		MOV	E,A
   621 E768 CD 15 E5      		CALL	GETSETUC;and set it.
   622 E76B CD B8 E4      		CALL	RESDSK	;reset the disk system.
   623 E76E 32 AB EB      		STA	BATCH	;clear batch mode flag.
   624 E771 C1            		POP	B
   625 E772 79            		MOV	A,C
   626 E773 E6 0F         		ANI	0FH	;isolate the drive number.
   627 E775 32 EF EB      		STA	CDRIVE	;and save.
   628 E778 CD BD E4      		CALL	DSKSEL	;...and select.
   629 E77B 3A 07 E4      		LDA	INBUFF+1
   630 E77E B7            		ORA	A	;anything in input buffer already?
   631 E77F C2 98 E7      		JNZ	CMMND2	;yes, we just process it.
   632                    	;
   633                    	;   Entry point to get a command line from the console.
   634                    	;
   635 E782 31 AB EB      	CMMND1	LXI	SP,CCPSTACK;set stack straight.
   636 E785 CD 98 E4      		CALL	CRLF	;start a new line on the screen.
   637 E788 CD D0 E5      		CALL	GETDSK	;get current drive.
   638 E78B C6 61         		ADI	'a'
   639 E78D CD 8C E4      		CALL	PRINT	;print current drive.
   640 E790 3E 3E         		MVI	A,'>'
   641 E792 CD 8C E4      		CALL	PRINT	;and add prompt.
   642 E795 CD 39 E5      		CALL	GETINP	;get line from user.
   643                    	;
   644                    	;   Process command line here.
   645                    	;
   646 E798 11 80 00      	CMMND2	LXI	D,TBUFF
   647 E79B CD D8 E5      		CALL	DMASET	;set standard dma address.
   648 E79E CD D0 E5      		CALL	GETDSK
   649 E7A1 32 EF EB      		STA	CDRIVE	;set current drive.
   650 E7A4 CD 5E E6      		CALL	CONVFST	;convert name typed in.
   651 E7A7 C4 09 E6      		CNZ	SYNERR	;wild cards are not allowed.
   652 E7AA 3A F0 EB      		LDA	CHGDRV	;if a change in drives was indicated,
   653 E7AD B7            		ORA	A	;then treat this as an unknown command
   654 E7AE C2 A5 EA      		JNZ	UNKNOWN	;which gets executed.
   655 E7B1 CD 2E E7      		CALL	SEARCH	;else search command table for a match.
   656                    	;
   657                    	;   Note that an unknown command returns
   658                    	; with (A) pointing to the last address
   659                    	; in our table which is (UNKNOWN).
   660                    	;
   661 E7B4 21 C1 E7      		LXI	H,CMDADR;now, look thru our address table for command (A).
   662 E7B7 5F            		MOV	E,A	;set (DE) to command number.
   663 E7B8 16 00         		MVI	D,0
   664 E7BA 19            		DAD	D
   665 E7BB 19            		DAD	D	;(HL)=(CMDADR)+2*(command number).
   666 E7BC 7E            		MOV	A,M	;now pick out this address.
   667 E7BD 23            		INX	H
   668 E7BE 66            		MOV	H,M
   669 E7BF 6F            		MOV	L,A
   670 E7C0 E9            		PCHL		;now execute it.
   671                    	;
   672                    	;   CP/M command address table.
   673                    	;
   674 E7C1               	CMDADR	DW	DIRECT,ERASE,TYPE,SAVE
            77 E8 1F E9 
            5D E9 AD E9 
   675 E7C9               		DW	RENAME,USER,UNKNOWN
            10 EA 8E EA 
            A5 EA 
   676                    	;
   677                    	;   Halt the system. Reason for this is unknown at present.
   678                    	;
   679 E7CF 21 F3 76      	HALT	LXI	H,76F3H	;'DI HLT' instructions.
   680 E7D2 22 00 E4      		SHLD	CBASE
   681 E7D5 21 00 E4      		LXI	H,CBASE
   682 E7D8 E9            		PCHL
   683                    	;
   684                    	;   Read error while TYPEing a file.
   685                    	;
   686 E7D9 01 DF E7      	RDERROR	LXI	B,RDERR
   687 E7DC C3 A7 E4      		JMP	PLINE
   688 E7DF               	RDERR	DB	'Read error',0
            52 65 61 64 
            20 65 72 72 
            6F 72 00 
   689                    	;
   690                    	;   Required file was not located.
   691                    	;
   692 E7EA 01 F0 E7      	NONE	LXI	B,NOFILE
   693 E7ED C3 A7 E4      		JMP	PLINE
   694 E7F0               	NOFILE	DB	'No file',0
            4E 6F 20 66 
            69 6C 65 00 
   695                    	;
   696                    	;   Decode a command of the form 'A>filename number{ filename}.
   697                    	; Note that a drive specifier is not allowed on the first file
   698                    	; name. On return, the number is in register (A). Any error
   699                    	; causes 'filename?' to be printed and the command is aborted.
   700                    	;
   701 E7F8 CD 5E E6      	DECODE	CALL	CONVFST	;convert filename.
   702 E7FB 3A F0 EB      		LDA	CHGDRV	;do not allow a drive to be specified.
   703 E7FE B7            		ORA	A
   704 E7FF C2 09 E6      		JNZ	SYNERR
   705 E802 21 CE EB      		LXI	H,FCB+1	;convert number now.
   706 E805 01 0B 00      		LXI	B,11	;(B)=sum register, (C)=max digit count.
   707 E808 7E            	DECODE1	MOV	A,M
   708 E809 FE 20         		CPI	' '	;a space terminates the numeral.
   709 E80B CA 33 E8      		JZ	DECODE3
   710 E80E 23            		INX	H
   711 E80F D6 30         		SUI	'0'	;make binary from ascii.
   712 E811 FE 0A         		CPI	10	;legal digit?
   713 E813 D2 09 E6      		JNC	SYNERR
   714 E816 57            		MOV	D,A	;yes, save it in (D).
   715 E817 78            		MOV	A,B	;compute (B)=(B)*10 and check for overflow.
   716 E818 E6 E0         		ANI	0E0H
   717 E81A C2 09 E6      		JNZ	SYNERR
   718 E81D 78            		MOV	A,B
   719 E81E 07            		RLC
   720 E81F 07            		RLC
   721 E820 07            		RLC	;(A)=(B)*8
   722 E821 80            		ADD	B	;.......*9
   723 E822 DA 09 E6      		JC	SYNERR
   724 E825 80            		ADD	B	;.......*10
   725 E826 DA 09 E6      		JC	SYNERR
   726 E829 82            		ADD	D	;add in new digit now.
   727 E82A DA 09 E6      	DECODE2	JC	SYNERR
   728 E82D 47            		MOV	B,A	;and save result.
   729 E82E 0D            		DCR	C	;only look at 11 digits.
   730 E82F C2 08 E8      		JNZ	DECODE1
   731 E832 C9            		RET
   732 E833 7E            	DECODE3	MOV	A,M	;spaces must follow (why?).
   733 E834 FE 20         		CPI	' '
   734 E836 C2 09 E6      		JNZ	SYNERR
   735 E839 23            		INX	H
   736 E83A 0D            	DECODE4	DCR	C
   737 E83B C2 33 E8      		JNZ	DECODE3
   738 E83E 78            		MOV	A,B	;set (A)=the numeric value entered.
   739 E83F C9            		RET
   740                    	;
   741                    	;   Move 3 bytes from (HL) to (DE). Note that there is only
   742                    	; one reference to this at (A2D5h).
   743                    	;
   744 E840 06 03         	MOVE3	MVI	B,3
   745                    	;
   746                    	;   Move (B) bytes from (HL) to (DE).
   747                    	;
   748 E842 7E            	HL2DE	MOV	A,M
   749 E843 12            		STAX	D
   750 E844 23            		INX	H
   751 E845 13            		INX	D
   752 E846 05            		DCR	B
   753 E847 C2 42 E8      		JNZ	HL2DE
   754 E84A C9            		RET
   755                    	;
   756                    	;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
   757                    	;
   758 E84B 21 80 00      	EXTRACT	LXI	H,TBUFF
   759 E84E 81            		ADD	C
   760 E84F CD 59 E6      		CALL	ADDHL
   761 E852 7E            		MOV	A,M
   762 E853 C9            		RET
   763                    	;
   764                    	;  Check drive specified. If it means a change, then the new
   765                    	; drive will be selected. In any case, the drive byte of the
   766                    	; fcb will be set to null (means use current drive).
   767                    	;
   768 E854 AF            	DSELECT	XRA	A	;null out first byte of fcb.
   769 E855 32 CD EB      		STA	FCB
   770 E858 3A F0 EB      		LDA	CHGDRV	;a drive change indicated?
   771 E85B B7            		ORA	A
   772 E85C C8            		RZ
   773 E85D 3D            		DCR	A	;yes, is it the same as the current drive?
   774 E85E 21 EF EB      		LXI	H,CDRIVE
   775 E861 BE            		CMP	M
   776 E862 C8            		RZ
   777 E863 C3 BD E4      		JMP	DSKSEL	;no. Select it then.
   778                    	;
   779                    	;   Check the drive selection and reset it to the previous
   780                    	; drive if it was changed for the preceeding command.
   781                    	;
   782 E866 3A F0 EB      	RESETDR	LDA	CHGDRV	;drive change indicated?
   783 E869 B7            		ORA	A
   784 E86A C8            		RZ
   785 E86B 3D            		DCR	A	;yes, was it a different drive?
   786 E86C 21 EF EB      		LXI	H,CDRIVE
   787 E86F BE            		CMP	M
   788 E870 C8            		RZ
   789 E871 3A EF EB      		LDA	CDRIVE	;yes, re-select our old drive.
   790 E874 C3 BD E4      		JMP	DSKSEL
   791                    	;
   792                    	;**************************************************************
   793                    	;*
   794                    	;*           D I R E C T O R Y   C O M M A N D
   795                    	;*
   796                    	;**************************************************************
   797                    	;
   798 E877 CD 5E E6      	DIRECT	CALL	CONVFST	;convert file name.
   799 E87A CD 54 E8      		CALL	DSELECT	;select indicated drive.
   800 E87D 21 CE EB      		LXI	H,FCB+1	;was any file indicated?
   801 E880 7E            		MOV	A,M
   802 E881 FE 20         		CPI	' '
   803 E883 C2 8F E8      		JNZ	DIRECT2
   804 E886 06 0B         		MVI	B,11	;no. Fill field with '?' - same as *.*.
   805 E888 36 3F         	DIRECT1	MVI	M,'?'
   806 E88A 23            		INX	H
   807 E88B 05            		DCR	B
   808 E88C C2 88 E8      		JNZ	DIRECT1
   809 E88F 1E 00         	DIRECT2	MVI	E,0	;set initial cursor position.
   810 E891 D5            		PUSH	D
   811 E892 CD E9 E4      		CALL	SRCHFCB	;get first file name.
   812 E895 CC EA E7      		CZ	NONE	;none found at all?
   813 E898 CA 1B E9      	DIRECT3	JZ	DIRECT9	;terminate if no more names.
   814 E89B 3A EE EB      		LDA	RTNCODE	;get file's position in segment (0-3).
   815 E89E 0F            		RRC
   816 E89F 0F            		RRC
   817 E8A0 0F            		RRC
   818 E8A1 E6 60         		ANI	60H	;(A)=position*32
   819 E8A3 4F            		MOV	C,A
   820 E8A4 3E 0A         		MVI	A,10
   821 E8A6 CD 4B E8      		CALL	EXTRACT	;extract the tenth entry in fcb.
   822 E8A9 17            		RAL		;check system file status bit.
   823 E8AA DA 0F E9      		JC	DIRECT8	;we don't list them.
   824 E8AD D1            		POP	D
   825 E8AE 7B            		MOV	A,E	;bump name count.
   826 E8AF 1C            		INR	E
   827 E8B0 D5            		PUSH	D
   828 E8B1 E6 03         		ANI	03H	;at end of line?
   829 E8B3 F5            		PUSH	PSW
   830 E8B4 C2 CC E8      		JNZ	DIRECT4
   831 E8B7 CD 98 E4      		CALL	CRLF	;yes, end this line and start another.
   832 E8BA C5            		PUSH	B
   833 E8BB CD D0 E5      		CALL	GETDSK	;start line with ('A:').
   834 E8BE C1            		POP	B
   835 E8BF C6 41         		ADI	'A'
   836 E8C1 CD 92 E4      		CALL	PRINTB
   837 E8C4 3E 3A         		MVI	A,':'
   838 E8C6 CD 92 E4      		CALL	PRINTB
   839 E8C9 C3 D4 E8      		JMP	DIRECT5
   840 E8CC CD A2 E4      	DIRECT4	CALL	SPACE	;add seperator between file names.
   841 E8CF 3E 3A         		MVI	A,':'
   842 E8D1 CD 92 E4      		CALL	PRINTB
   843 E8D4 CD A2 E4      	DIRECT5	CALL	SPACE
   844 E8D7 06 01         		MVI	B,1	;'extract' each file name character at a time.
   845 E8D9 78            	DIRECT6	MOV	A,B
   846 E8DA CD 4B E8      		CALL	EXTRACT
   847 E8DD E6 7F         		ANI	7FH	;strip bit 7 (status bit).
   848 E8DF FE 20         		CPI	' '	;are we at the end of the name?
   849 E8E1 C2 F9 E8      		JNZ	DRECT65
   850 E8E4 F1            		POP	PSW	;yes, don't print spaces at the end of a line.
   851 E8E5 F5            		PUSH	PSW
   852 E8E6 FE 03         		CPI	3
   853 E8E8 C2 F7 E8      		JNZ	DRECT63
   854 E8EB 3E 09         		MVI	A,9	;first check for no extension.
   855 E8ED CD 4B E8      		CALL	EXTRACT
   856 E8F0 E6 7F         		ANI	7FH
   857 E8F2 FE 20         		CPI	' '
   858 E8F4 CA 0E E9      		JZ	DIRECT7	;don't print spaces.
   859 E8F7 3E 20         	DRECT63	MVI	A,' '	;else print them.
   860 E8F9 CD 92 E4      	DRECT65	CALL	PRINTB
   861 E8FC 04            		INR	B	;bump to next character psoition.
   862 E8FD 78            		MOV	A,B
   863 E8FE FE 0C         		CPI	12	;end of the name?
   864 E900 D2 0E E9      		JNC	DIRECT7
   865 E903 FE 09         		CPI	9	;nope, starting extension?
   866 E905 C2 D9 E8      		JNZ	DIRECT6
   867 E908 CD A2 E4      		CALL	SPACE	;yes, add seperating space.
   868 E90B C3 D9 E8      		JMP	DIRECT6
   869 E90E F1            	DIRECT7	POP	PSW	;get the next file name.
   870 E90F CD C2 E5      	DIRECT8	CALL	CHKCON	;first check console, quit on anything.
   871 E912 C2 1B E9      		JNZ	DIRECT9
   872 E915 CD E4 E4      		CALL	SRCHNXT	;get next name.
   873 E918 C3 98 E8      		JMP	DIRECT3	;and continue with our list.
   874 E91B D1            	DIRECT9	POP	D	;restore the stack and return to command level.
   875 E91C C3 86 EB      		JMP	GETBACK
   876                    	;
   877                    	;**************************************************************
   878                    	;*
   879                    	;*                E R A S E   C O M M A N D
   880                    	;*
   881                    	;**************************************************************
   882                    	;
   883 E91F CD 5E E6      	ERASE	CALL	CONVFST	;convert file name.
   884 E922 FE 0B         		CPI	11	;was '*.*' entered?
   885 E924 C2 42 E9      		JNZ	ERASE1
   886 E927 01 52 E9      		LXI	B,YESNO	;yes, ask for confirmation.
   887 E92A CD A7 E4      		CALL	PLINE
   888 E92D CD 39 E5      		CALL	GETINP
   889 E930 21 07 E4      		LXI	H,INBUFF+1
   890 E933 35            		DCR	M	;must be exactly 'y'.
   891 E934 C2 82 E7      		JNZ	CMMND1
   892 E937 23            		INX	H
   893 E938 7E            		MOV	A,M
   894 E939 FE 59         		CPI	'Y'
   895 E93B C2 82 E7      		JNZ	CMMND1
   896 E93E 23            		INX	H
   897 E93F 22 88 E4      		SHLD	INPOINT	;save input line pointer.
   898 E942 CD 54 E8      	ERASE1	CALL	DSELECT	;select desired disk.
   899 E945 11 CD EB      		LXI	D,FCB
   900 E948 CD EF E4      		CALL	DELETE	;delete the file.
   901 E94B 3C            		INR	A
   902 E94C CC EA E7      		CZ	NONE	;not there?
   903 E94F C3 86 EB      		JMP	GETBACK	;return to command level now.
   904 E952               	YESNO	DB	'All (y/n)?',0
            41 6C 6C 20 
            28 79 2F 6E 
            29 3F 00 
   905                    	;
   906                    	;**************************************************************
   907                    	;*
   908                    	;*            T Y P E   C O M M A N D
   909                    	;*
   910                    	;**************************************************************
   911                    	;
   912 E95D CD 5E E6      	TYPE	CALL	CONVFST	;convert file name.
   913 E960 C2 09 E6      		JNZ	SYNERR	;wild cards not allowed.
   914 E963 CD 54 E8      		CALL	DSELECT	;select indicated drive.
   915 E966 CD D0 E4      		CALL	OPENFCB	;open the file.
   916 E969 CA A7 E9      		JZ	TYPE5	;not there?
   917 E96C CD 98 E4      		CALL	CRLF	;ok, start a new line on the screen.
   918 E96F 21 F1 EB      		LXI	H,NBYTES;initialize byte counter.
   919 E972 36 FF         		MVI	M,0FFH	;set to read first sector.
   920 E974 21 F1 EB      	TYPE1	LXI	H,NBYTES
   921 E977 7E            	TYPE2	MOV	A,M	;have we written the entire sector?
   922 E978 FE 80         		CPI	128
   923 E97A DA 87 E9      		JC	TYPE3
   924 E97D E5            		PUSH	H	;yes, read in the next one.
   925 E97E CD FE E4      		CALL	READFCB
   926 E981 E1            		POP	H
   927 E982 C2 A0 E9      		JNZ	TYPE4	;end or error?
   928 E985 AF            		XRA	A	;ok, clear byte counter.
   929 E986 77            		MOV	M,A
   930 E987 34            	TYPE3	INR	M	;count this byte.
   931 E988 21 80 00      		LXI	H,TBUFF	;and get the (A)th one from the buffer (TBUFF).
   932 E98B CD 59 E6      		CALL	ADDHL
   933 E98E 7E            		MOV	A,M
   934 E98F FE 1A         		CPI	CNTRLZ	;end of file mark?
   935 E991 CA 86 EB      		JZ	GETBACK
   936 E994 CD 8C E4      		CALL	PRINT	;no, print it.
   937 E997 CD C2 E5      		CALL	CHKCON	;check console, quit if anything ready.
   938 E99A C2 86 EB      		JNZ	GETBACK
   939 E99D C3 74 E9      		JMP	TYPE1
   940                    	;
   941                    	;   Get here on an end of file or read error.
   942                    	;
   943 E9A0 3D            	TYPE4	DCR	A	;read error?
   944 E9A1 CA 86 EB      		JZ	GETBACK
   945 E9A4 CD D9 E7      		CALL	RDERROR	;yes, print message.
   946 E9A7 CD 66 E8      	TYPE5	CALL	RESETDR	;and reset proper drive
   947 E9AA C3 09 E6      		JMP	SYNERR	;now print file name with problem.
   948                    	;
   949                    	;**************************************************************
   950                    	;*
   951                    	;*            S A V E   C O M M A N D
   952                    	;*
   953                    	;**************************************************************
   954                    	;
   955 E9AD CD F8 E7      	SAVE	CALL	DECODE	;get numeric number that follows SAVE.
   956 E9B0 F5            		PUSH	PSW	;save number of pages to write.
   957 E9B1 CD 5E E6      		CALL	CONVFST	;convert file name.
   958 E9B4 C2 09 E6      		JNZ	SYNERR	;wild cards not allowed.
   959 E9B7 CD 54 E8      		CALL	DSELECT	;select specified drive.
   960 E9BA 11 CD EB      		LXI	D,FCB	;now delete this file.
   961 E9BD D5            		PUSH	D
   962 E9BE CD EF E4      		CALL	DELETE
   963 E9C1 D1            		POP	D
   964 E9C2 CD 09 E5      		CALL	CREATE	;and create it again.
   965 E9C5 CA FB E9      		JZ	SAVE3	;can't create?
   966 E9C8 AF            		XRA	A	;clear record number byte.
   967 E9C9 32 ED EB      		STA	FCB+32
   968 E9CC F1            		POP	PSW	;convert pages to sectors.
   969 E9CD 6F            		MOV	L,A
   970 E9CE 26 00         		MVI	H,0
   971 E9D0 29            		DAD	H	;(HL)=number of sectors to write.
   972 E9D1 11 00 01      		LXI	D,TBASE	;and we start from here.
   973 E9D4 7C            	SAVE1	MOV	A,H	;done yet?
   974 E9D5 B5            		ORA	L
   975 E9D6 CA F1 E9      		JZ	SAVE2
   976 E9D9 2B            		DCX	H	;nope, count this and compute the start
   977 E9DA E5            		PUSH	H	;of the next 128 byte sector.
   978 E9DB 21 80 00      		LXI	H,128
   979 E9DE 19            		DAD	D
   980 E9DF E5            		PUSH	H	;save it and set the transfer address.
   981 E9E0 CD D8 E5      		CALL	DMASET
   982 E9E3 11 CD EB      		LXI	D,FCB	;write out this sector now.
   983 E9E6 CD 04 E5      		CALL	WRTREC
   984 E9E9 D1            		POP	D	;reset (DE) to the start of the last sector.
   985 E9EA E1            		POP	H	;restore sector count.
   986 E9EB C2 FB E9      		JNZ	SAVE3	;write error?
   987 E9EE C3 D4 E9      		JMP	SAVE1
   988                    	;
   989                    	;   Get here after writing all of the file.
   990                    	;
   991 E9F1 11 CD EB      	SAVE2	LXI	D,FCB	;now close the file.
   992 E9F4 CD DA E4      		CALL	CLOSE
   993 E9F7 3C            		INR	A	;did it close ok?
   994 E9F8 C2 01 EA      		JNZ	SAVE4
   995                    	;
   996                    	;   Print out error message (no space).
   997                    	;
   998 E9FB 01 07 EA      	SAVE3	LXI	B,NOSPACE
   999 E9FE CD A7 E4      		CALL	PLINE
  1000 EA01 CD D5 E5      	SAVE4	CALL	STDDMA	;reset the standard dma address.
  1001 EA04 C3 86 EB      		JMP	GETBACK
  1002 EA07               	NOSPACE	DB	'No space',0
            4E 6F 20 73 
            70 61 63 65 
            00 
  1003                    	;
  1004                    	;**************************************************************
  1005                    	;*
  1006                    	;*           R E N A M E   C O M M A N D
  1007                    	;*
  1008                    	;**************************************************************
  1009                    	;
  1010 EA10 CD 5E E6      	RENAME	CALL	CONVFST	;convert first file name.
  1011 EA13 C2 09 E6      		JNZ	SYNERR	;wild cards not allowed.
  1012 EA16 3A F0 EB      		LDA	CHGDRV	;remember any change in drives specified.
  1013 EA19 F5            		PUSH	PSW
  1014 EA1A CD 54 E8      		CALL	DSELECT	;and select this drive.
  1015 EA1D CD E9 E4      		CALL	SRCHFCB	;is this file present?
  1016 EA20 C2 79 EA      		JNZ	RENAME6	;yes, print error message.
  1017 EA23 21 CD EB      		LXI	H,FCB	;yes, move this name into second slot.
  1018 EA26 11 DD EB      		LXI	D,FCB+16
  1019 EA29 06 10         		MVI	B,16
  1020 EA2B CD 42 E8      		CALL	HL2DE
  1021 EA2E 2A 88 E4      		LHLD	INPOINT	;get input pointer.
  1022 EA31 EB            		XCHG
  1023 EA32 CD 4F E6      		CALL	NONBLANK;get next non blank character.
  1024 EA35 FE 3D         		CPI	'='	;only allow an '=' or '_' seperator.
  1025 EA37 CA 3F EA      		JZ	RENAME1
  1026 EA3A FE 5F         		CPI	'_'
  1027 EA3C C2 73 EA      		JNZ	RENAME5
  1028 EA3F EB            	RENAME1	XCHG
  1029 EA40 23            		INX	H	;ok, skip seperator.
  1030 EA41 22 88 E4      		SHLD	INPOINT	;save input line pointer.
  1031 EA44 CD 5E E6      		CALL	CONVFST	;convert this second file name now.
  1032 EA47 C2 73 EA      		JNZ	RENAME5	;again, no wild cards.
  1033 EA4A F1            		POP	PSW	;if a drive was specified, then it
  1034 EA4B 47            		MOV	B,A	;must be the same as before.
  1035 EA4C 21 F0 EB      		LXI	H,CHGDRV
  1036 EA4F 7E            		MOV	A,M
  1037 EA50 B7            		ORA	A
  1038 EA51 CA 59 EA      		JZ	RENAME2
  1039 EA54 B8            		CMP	B
  1040 EA55 70            		MOV	M,B
  1041 EA56 C2 73 EA      		JNZ	RENAME5	;they were different, error.
  1042 EA59 70            	RENAME2	MOV	M,B;	reset as per the first file specification.
  1043 EA5A AF            		XRA	A
  1044 EA5B 32 CD EB      		STA	FCB	;clear the drive byte of the fcb.
  1045 EA5E CD E9 E4      	RENAME3	CALL	SRCHFCB	;and go look for second file.
  1046 EA61 CA 6D EA      		JZ	RENAME4	;doesn't exist?
  1047 EA64 11 CD EB      		LXI	D,FCB
  1048 EA67 CD 0E E5      		CALL	RENAM	;ok, rename the file.
  1049 EA6A C3 86 EB      		JMP	GETBACK
  1050                    	;
  1051                    	;   Process rename errors here.
  1052                    	;
  1053 EA6D CD EA E7      	RENAME4	CALL	NONE	;file not there.
  1054 EA70 C3 86 EB      		JMP	GETBACK
  1055 EA73 CD 66 E8      	RENAME5	CALL	RESETDR	;bad command format.
  1056 EA76 C3 09 E6      		JMP	SYNERR
  1057 EA79 01 82 EA      	RENAME6	LXI	B,EXISTS;destination file already exists.
  1058 EA7C CD A7 E4      		CALL	PLINE
  1059 EA7F C3 86 EB      		JMP	GETBACK
  1060 EA82               	EXISTS	DB	'File exists',0
            46 69 6C 65 
            20 65 78 69 
            73 74 73 00 
  1061                    	;
  1062                    	;**************************************************************
  1063                    	;*
  1064                    	;*             U S E R   C O M M A N D
  1065                    	;*
  1066                    	;**************************************************************
  1067                    	;
  1068 EA8E CD F8 E7      	USER	CALL	DECODE	;get numeric value following command.
  1069 EA91 FE 10         		CPI	16	;legal user number?
  1070 EA93 D2 09 E6      		JNC	SYNERR
  1071 EA96 5F            		MOV	E,A	;yes but is there anything else?
  1072 EA97 3A CE EB      		LDA	FCB+1
  1073 EA9A FE 20         		CPI	' '
  1074 EA9C CA 09 E6      		JZ	SYNERR	;yes, that is not allowed.
  1075 EA9F CD 15 E5      		CALL	GETSETUC;ok, set user code.
  1076 EAA2 C3 89 EB      		JMP	GETBACK1
  1077                    	;
  1078                    	;**************************************************************
  1079                    	;*
  1080                    	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
  1081                    	;*
  1082                    	;**************************************************************
  1083                    	;
  1084 EAA5 CD F5 E5      	UNKNOWN	CALL	VERIFY	;check for valid system (why?).
  1085 EAA8 3A CE EB      		LDA	FCB+1	;anything to execute?
  1086 EAAB FE 20         		CPI	' '
  1087 EAAD C2 C4 EA      		JNZ	UNKWN1
  1088 EAB0 3A F0 EB      		LDA	CHGDRV	;nope, only a drive change?
  1089 EAB3 B7            		ORA	A
  1090 EAB4 CA 89 EB      		JZ	GETBACK1;neither???
  1091 EAB7 3D            		DCR	A
  1092 EAB8 32 EF EB      		STA	CDRIVE	;ok, store new drive.
  1093 EABB CD 29 E5      		CALL	MOVECD	;set (TDRIVE) also.
  1094 EABE CD BD E4      		CALL	DSKSEL	;and select this drive.
  1095 EAC1 C3 89 EB      		JMP	GETBACK1;then return.
  1096                    	;
  1097                    	;   Here a file name was typed. Prepare to execute it.
  1098                    	;
  1099 EAC4 11 D6 EB      	UNKWN1	LXI	D,FCB+9	;an extension specified?
  1100 EAC7 1A            		LDAX	D
  1101 EAC8 FE 20         		CPI	' '
  1102 EACA C2 09 E6      		JNZ	SYNERR	;yes, not allowed.
  1103 EACD D5            	UNKWN2	PUSH	D
  1104 EACE CD 54 E8      		CALL	DSELECT	;select specified drive.
  1105 EAD1 D1            		POP	D
  1106 EAD2 21 83 EB      		LXI	H,COMFILE	;set the extension to 'COM'.
  1107 EAD5 CD 40 E8      		CALL	MOVE3
  1108 EAD8 CD D0 E4      		CALL	OPENFCB	;and open this file.
  1109 EADB CA 6B EB      		JZ	UNKWN9	;not present?
  1110                    	;
  1111                    	;   Load in the program.
  1112                    	;
  1113 EADE 21 00 01      		LXI	H,TBASE	;store the program starting here.
  1114 EAE1 E5            	UNKWN3	PUSH	H
  1115 EAE2 EB            		XCHG
  1116 EAE3 CD D8 E5      		CALL	DMASET	;set transfer address.
  1117 EAE6 11 CD EB      		LXI	D,FCB	;and read the next record.
  1118 EAE9 CD F9 E4      		CALL	RDREC
  1119 EAEC C2 01 EB      		JNZ	UNKWN4	;end of file or read error?
  1120 EAEF E1            		POP	H	;nope, bump pointer for next sector.
  1121 EAF0 11 80 00      		LXI	D,128
  1122 EAF3 19            		DAD	D
  1123 EAF4 11 00 E4      		LXI	D,CBASE	;enough room for the whole file?
  1124 EAF7 7D            		MOV	A,L
  1125 EAF8 93            		SUB	E
  1126 EAF9 7C            		MOV	A,H
  1127 EAFA 9A            		SBB	D
  1128 EAFB D2 71 EB      		JNC	UNKWN0	;no, it can't fit.
  1129 EAFE C3 E1 EA      		JMP	UNKWN3
  1130                    	;
  1131                    	;   Get here after finished reading.
  1132                    	;
  1133 EB01 E1            	UNKWN4	POP	H
  1134 EB02 3D            		DCR	A	;normal end of file?
  1135 EB03 C2 71 EB      		JNZ	UNKWN0
  1136 EB06 CD 66 E8      		CALL	RESETDR	;yes, reset previous drive.
  1137 EB09 CD 5E E6      		CALL	CONVFST	;convert the first file name that follows
  1138 EB0C 21 F0 EB      		LXI	H,CHGDRV;command name.
  1139 EB0F E5            		PUSH	H
  1140 EB10 7E            		MOV	A,M	;set drive code in default fcb.
  1141 EB11 32 CD EB      		STA	FCB
  1142 EB14 3E 10         		MVI	A,16	;put second name 16 bytes later.
  1143 EB16 CD 60 E6      		CALL	CONVERT	;convert second file name.
  1144 EB19 E1            		POP	H
  1145 EB1A 7E            		MOV	A,M	;and set the drive for this second file.
  1146 EB1B 32 DD EB      		STA	FCB+16
  1147 EB1E AF            		XRA	A	;clear record byte in fcb.
  1148 EB1F 32 ED EB      		STA	FCB+32
  1149 EB22 11 5C 00      		LXI	D,TFCB	;move it into place at(005Ch).
  1150 EB25 21 CD EB      		LXI	H,FCB
  1151 EB28 06 21         		MVI	B,33
  1152 EB2A CD 42 E8      		CALL	HL2DE
  1153 EB2D 21 08 E4      		LXI	H,INBUFF+2;now move the remainder of the input
  1154 EB30 7E            	UNKWN5	MOV	A,M	;line down to (0080h). Look for a non blank.
  1155 EB31 B7            		ORA	A	;or a null.
  1156 EB32 CA 3E EB      		JZ	UNKWN6
  1157 EB35 FE 20         		CPI	' '
  1158 EB37 CA 3E EB      		JZ	UNKWN6
  1159 EB3A 23            		INX	H
  1160 EB3B C3 30 EB      		JMP	UNKWN5
  1161                    	;
  1162                    	;   Do the line move now. It ends in a null byte.
  1163                    	;
  1164 EB3E 06 00         	UNKWN6	MVI	B,0	;keep a character count.
  1165 EB40 11 81 00      		LXI	D,TBUFF+1;data gets put here.
  1166 EB43 7E            	UNKWN7	MOV	A,M	;move it now.
  1167 EB44 12            		STAX	D
  1168 EB45 B7            		ORA	A
  1169 EB46 CA 4F EB      		JZ	UNKWN8
  1170 EB49 04            		INR	B
  1171 EB4A 23            		INX	H
  1172 EB4B 13            		INX	D
  1173 EB4C C3 43 EB      		JMP	UNKWN7
  1174 EB4F 78            	UNKWN8	MOV	A,B	;now store the character count.
  1175 EB50 32 80 00      		STA	TBUFF
  1176 EB53 CD 98 E4      		CALL	CRLF	;clean up the screen.
  1177 EB56 CD D5 E5      		CALL	STDDMA	;set standard transfer address.
  1178 EB59 CD 1A E5      		CALL	SETCDRV	;reset current drive.
  1179 EB5C CD 00 01      		CALL	TBASE	;and execute the program.
  1180                    	;
  1181                    	;   Transiant programs return here (or reboot).
  1182                    	;
  1183 EB5F 31 AB EB      		LXI	SP,BATCH	;set stack first off.
  1184 EB62 CD 29 E5      		CALL	MOVECD	;move current drive into place (TDRIVE).
  1185 EB65 CD BD E4      		CALL	DSKSEL	;and reselect it.
  1186 EB68 C3 82 E7      		JMP	CMMND1	;back to comand mode.
  1187                    	;
  1188                    	;   Get here if some error occured.
  1189                    	;
  1190 EB6B CD 66 E8      	UNKWN9	CALL	RESETDR	;inproper format.
  1191 EB6E C3 09 E6      		JMP	SYNERR
  1192 EB71 01 7A EB      	UNKWN0	LXI	B,BADLOAD;read error or won't fit.
  1193 EB74 CD A7 E4      		CALL	PLINE
  1194 EB77 C3 86 EB      		JMP	GETBACK
  1195 EB7A               	BADLOAD	DB	'Bad load',0
            42 61 64 20 
            6C 6F 61 64 
            00 
  1196 EB83               	COMFILE	DB	'COM'	;command file extension.
            43 4F 4D 
  1197                    	;
  1198                    	;   Get here to return to command level. We will reset the
  1199                    	; previous active drive and then either return to command
  1200                    	; level directly or print error message and then return.
  1201                    	;
  1202 EB86 CD 66 E8      	GETBACK	CALL	RESETDR	;reset previous drive.
  1203 EB89 CD 5E E6      	GETBACK1:CALL	CONVFST	;convert first name in (FCB).
  1204 EB8C 3A CE EB      		LDA	FCB+1	;if this was just a drive change request,
  1205 EB8F D6 20         		SUI	' '	;make sure it was valid.
  1206 EB91 21 F0 EB      		LXI	H,CHGDRV
  1207 EB94 B6            		ORA	M
  1208 EB95 C2 09 E6      		JNZ	SYNERR
  1209 EB98 C3 82 E7      		JMP	CMMND1	;ok, return to command level.
  1210                    	;
  1211                    	;   ccp stack area.
  1212                    	;
  1213 EB9B               		DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
  1214      EB AB         	CCPSTACK:EQU	$	;end of ccp stack area.
  1215                    	;
  1216                    	;   Batch (or SUBMIT) processing information storage.
  1217                    	;
  1218 EBAB               	BATCH	DB	0	;batch mode flag (0=not active).
            00 
  1219 EBAC               	BATCHFCB:DB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 24 24 24 
            20 20 20 20 
            20 53 55 42 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 
  1220                    	;
  1221                    	;   File control block setup by the CCP.
  1222                    	;
  1223 EBCD               	FCB	DB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
            00 20 20 20 
            20 20 20 20 
            20 20 20 20 
            00 00 00 00 
            00 20 20 20 
            20 20 20 20 
            20 20 20 20 
            00 00 00 00 
            00 
  1224 EBEE               	RTNCODE	DB	0	;status returned from bdos call.
            00 
  1225 EBEF               	CDRIVE	DB	0	;currently active drive.
            00 
  1226 EBF0               	CHGDRV	DB	0	;change in drives flag (0=no change).
            00 
  1227 EBF1               	NBYTES	DW	0	;byte counter used by TYPE.
            00 00 
  1228                    	;
  1229                    	;   Room for expansion?
  1230                    	;
  1231 EBF3               		DB	0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 
  1232                    	;
  1233                    	;   Note that the following six bytes must match those at
  1234                    	; (PATTRN1) or cp/m will HALT. Why?
  1235                    	;
  1236 EC00               	PATTRN2	DB	0,22,0,0,0,0;(* serial number bytes *).
            00 16 00 00 
            00 00 
  1237                    	;
  1238                    	;**************************************************************
  1239                    	;*
  1240                    	;*                    B D O S   E N T R Y
  1241                    	;*
  1242                    	;**************************************************************
  1243                    	;
  1244 EC06 C3 11 EC      	FBASE	JMP	FBASE1
  1245                    	;
  1246                    	;   Bdos error table.
  1247                    	;
  1248 EC09               	BADSCTR	DW	ERROR1	;bad sector on read or write.
            99 EC 
  1249 EC0B               	BADSLCT	DW	ERROR2	;bad disk select.
            A5 EC 
  1250 EC0D               	RODISK	DW	ERROR3	;disk is read only.
            AB EC 
  1251 EC0F               	ROFILE	DW	ERROR4	;file is read only.
            B1 EC 
  1252                    	;
  1253                    	;   Entry into bdos. (DE) or (E) are the parameters passed. The
  1254                    	; function number desired is in register (C).
  1255                    	;
  1256 EC11 EB            	FBASE1	XCHG		;save the (DE) parameters.
  1257 EC12 22 43 EF      		SHLD	PARAMS
  1258 EC15 EB            		XCHG
  1259 EC16 7B            		MOV	A,E	;and save register (E) in particular.
  1260 EC17 32 D6 F9      		STA	EPARAM
  1261 EC1A 21 00 00      		LXI	H,0
  1262 EC1D 22 45 EF      		SHLD	STATUS	;clear return status.
  1263 EC20 39            		DAD	SP
  1264 EC21 22 0F EF      		SHLD	USRSTACK;save users stack pointer.
  1265 EC24 31 41 EF      		LXI	SP,STKAREA;and set our own.
  1266 EC27 AF            		XRA	A	;clear auto select storage space.
  1267 EC28 32 E0 F9      		STA	AUTOFLAG
  1268 EC2B 32 DE F9      		STA	AUTO
  1269 EC2E 21 74 F9      		LXI	H,GOBACK;set return address.
  1270 EC31 E5            		PUSH	H
  1271 EC32 79            		MOV	A,C	;get function number.
  1272 EC33 FE 29         		CPI	NFUNCTS	;valid function number?
  1273 EC35 D0            		RNC
  1274 EC36 4B            		MOV	C,E	;keep single register function here.
  1275 EC37 21 47 EC      		LXI	H,FUNCTNS;now look thru the function table.
  1276 EC3A 5F            		MOV	E,A
  1277 EC3B 16 00         		MVI	D,0	;(DE)=function number.
  1278 EC3D 19            		DAD	D
  1279 EC3E 19            		DAD	D	;(HL)=(start of table)+2*(function number).
  1280 EC3F 5E            		MOV	E,M
  1281 EC40 23            		INX	H
  1282 EC41 56            		MOV	D,M	;now (DE)=address for this function.
  1283 EC42 2A 43 EF      		LHLD	PARAMS	;retrieve parameters.
  1284 EC45 EB            		XCHG		;now (DE) has the original parameters.
  1285 EC46 E9            		PCHL		;execute desired function.
  1286                    	;
  1287                    	;   BDOS function jump table.
  1288                    	;
  1289      00 29         	NFUNCTS	EQU	41	;number of functions in followin table.
  1290                    	;
  1291 EC47               	FUNCTNS	DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
            03 FA C8 EE 
            90 ED CE EE 
            12 FA 0F FA 
            D4 EE ED EE 
  1292 EC57               		DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
            F3 EE F8 EE 
            E1 ED FE EE 
            7E F8 83 F8 
            45 F8 9C F8 
  1293 EC67               		DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
            A5 F8 AB F8 
            C8 F8 D7 F8 
            E0 F8 E6 F8 
            EC F8 
  1294 EC75               		DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
            F5 F8 FE F8 
            04 F9 0A F9 
            11 F9 2C F1 
            17 F9 1D F9 
  1295 EC85               		DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
            26 F9 2D F9 
            41 F9 47 F9 
            4D F9 0E F8 
            53 F9 04 EF 
  1296 EC95               		DW	RTN,WTSPECL
            04 EF 9B F9 
  1297                    	;
  1298                    	;   Bdos error message section.
  1299                    	;
  1300 EC99 21 CA EC      	ERROR1	LXI	H,BADSEC	;bad sector message.
  1301 EC9C CD E5 EC      		CALL	PRTERR	;print it and get a 1 char responce.
  1302 EC9F FE 03         		CPI	CNTRLC	;re-boot request (control-c)?
  1303 ECA1 CA 00 00      		JZ	0	;yes.
  1304 ECA4 C9            		RET		;no, return to retry i/o function.
  1305                    	;
  1306 ECA5 21 D5 EC      	ERROR2	LXI	H,BADSEL	;bad drive selected.
  1307 ECA8 C3 B4 EC      		JMP	ERROR5
  1308                    	;
  1309 ECAB 21 E1 EC      	ERROR3	LXI	H,DISKRO	;disk is read only.
  1310 ECAE C3 B4 EC      		JMP	ERROR5
  1311                    	;
  1312 ECB1 21 DC EC      	ERROR4	LXI	H,FILERO	;file is read only.
  1313                    	;
  1314 ECB4 CD E5 EC      	ERROR5	CALL	PRTERR
  1315 ECB7 C3 00 00      		JMP	0	;always reboot on these errors.
  1316                    	;
  1317 ECBA               	BDOSERR	DB	'Bdos Err On '
            42 64 6F 73 
            20 45 72 72 
            20 4F 6E 20 
  1318 ECC6               	BDOSDRV	DB	' : $'
            20 3A 20 24 
  1319 ECCA               	BADSEC	DB	'Bad Sector$'
            42 61 64 20 
            53 65 63 74 
            6F 72 24 
  1320 ECD5               	BADSEL	DB	'Select$'
            53 65 6C 65 
            63 74 24 
  1321 ECDC               	FILERO	DB	'File '
            46 69 6C 65 
            20 
  1322 ECE1               	DISKRO	DB	'R/O$'
            52 2F 4F 24 
  1323                    	;
  1324                    	;   Print bdos error message.
  1325                    	;
  1326 ECE5 E5            	PRTERR	PUSH	H	;save second message pointer.
  1327 ECE6 CD C9 ED      		CALL	OUTCRLF	;send (cr)(lf).
  1328 ECE9 3A 42 EF      		LDA	ACTIVE	;get active drive.
  1329 ECEC C6 41         		ADI	'A'	;make ascii.
  1330 ECEE 32 C6 EC      		STA	BDOSDRV	;and put in message.
  1331 ECF1 01 BA EC      		LXI	B,BDOSERR;and print it.
  1332 ECF4 CD D3 ED      		CALL	PRTMESG
  1333 ECF7 C1            		POP	B	;print second message line now.
  1334 ECF8 CD D3 ED      		CALL	PRTMESG
  1335                    	;
  1336                    	;   Get an input character. We will check our 1 character
  1337                    	; buffer first. This may be set by the console status routine.
  1338                    	;
  1339 ECFB 21 0E EF      	GETCHAR	LXI	H,CHARBUF;check character buffer.
  1340 ECFE 7E            		MOV	A,M	;anything present already?
  1341 ECFF 36 00         		MVI	M,0	;...either case clear it.
  1342 ED01 B7            		ORA	A
  1343 ED02 C0            		RNZ		;yes, use it.
  1344 ED03 C3 09 FA      		JMP	CONIN	;nope, go get a character responce.
  1345                    	;
  1346                    	;   Input and echo a character.
  1347                    	;
  1348 ED06 CD FB EC      	GETECHO	CALL	GETCHAR	;input a character.
  1349 ED09 CD 14 ED      		CALL	CHKCHAR	;carriage control?
  1350 ED0C D8            		RC		;no, a regular control char so don't echo.
  1351 ED0D F5            		PUSH	PSW	;ok, save character now.
  1352 ED0E 4F            		MOV	C,A
  1353 ED0F CD 90 ED      		CALL	OUTCON	;and echo it.
  1354 ED12 F1            		POP	PSW	;get character and return.
  1355 ED13 C9            		RET
  1356                    	;
  1357                    	;   Check character in (A). Set the zero flag on a carriage
  1358                    	; control character and the carry flag on any other control
  1359                    	; character.
  1360                    	;
  1361 ED14 FE 0D         	CHKCHAR	CPI	CR	;check for carriage return, line feed, backspace,
  1362 ED16 C8            		RZ		;or a tab.
  1363 ED17 FE 0A         		CPI	LF
  1364 ED19 C8            		RZ
  1365 ED1A FE 09         		CPI	TAB
  1366 ED1C C8            		RZ
  1367 ED1D FE 08         		CPI	BS
  1368 ED1F C8            		RZ
  1369 ED20 FE 20         		CPI	' '	;other control char? Set carry flag.
  1370 ED22 C9            		RET
  1371                    	;
  1372                    	;   Check the console during output. Halt on a control-s, then
  1373                    	; reboot on a control-c. If anything else is ready, clear the
  1374                    	; zero flag and return (the calling routine may want to do
  1375                    	; something).
  1376                    	;
  1377 ED23 3A 0E EF      	CKCONSOL:LDA	CHARBUF	;check buffer.
  1378 ED26 B7            		ORA	A	;if anything, just return without checking.
  1379 ED27 C2 45 ED      		JNZ	CKCON2
  1380 ED2A CD 06 FA      		CALL	CONST	;nothing in buffer. Check console.
  1381 ED2D E6 01         		ANI	01H	;look at bit 0.
  1382 ED2F C8            		RZ		;return if nothing.
  1383 ED30 CD 09 FA      		CALL	CONIN	;ok, get it.
  1384 ED33 FE 13         		CPI	CNTRLS	;if not control-s, return with zero cleared.
  1385 ED35 C2 42 ED      		JNZ	CKCON1
  1386 ED38 CD 09 FA      		CALL	CONIN	;halt processing until another char
  1387 ED3B FE 03         		CPI	CNTRLC	;is typed. Control-c?
  1388 ED3D CA 00 00      		JZ	0	;yes, reboot now.
  1389 ED40 AF            		XRA	A	;no, just pretend nothing was ever ready.
  1390 ED41 C9            		RET
  1391 ED42 32 0E EF      	CKCON1	STA	CHARBUF	;save character in buffer for later processing.
  1392 ED45 3E 01         	CKCON2	MVI	A,1	;set (A) to non zero to mean something is ready.
  1393 ED47 C9            		RET
  1394                    	;
  1395                    	;   Output (C) to the screen. If the printer flip-flop flag
  1396                    	; is set, we will send character to printer also. The console
  1397                    	; will be checked in the process.
  1398                    	;
  1399 ED48 3A 0A EF      	OUTCHAR	LDA	OUTFLAG	;check output flag.
  1400 ED4B B7            		ORA	A	;anything and we won't generate output.
  1401 ED4C C2 62 ED      		JNZ	OUTCHR1
  1402 ED4F C5            		PUSH	B
  1403 ED50 CD 23 ED      		CALL	CKCONSOL;check console (we don't care whats there).
  1404 ED53 C1            		POP	B
  1405 ED54 C5            		PUSH	B
  1406 ED55 CD 0C FA      		CALL	CONOUT	;output (C) to the screen.
  1407 ED58 C1            		POP	B
  1408 ED59 C5            		PUSH	B
  1409 ED5A 3A 0D EF      		LDA	PRTFLAG	;check printer flip-flop flag.
  1410 ED5D B7            		ORA	A
  1411 ED5E C4 0F FA      		CNZ	LIST	;print it also if non-zero.
  1412 ED61 C1            		POP	B
  1413 ED62 79            	OUTCHR1	MOV	A,C	;update cursors position.
  1414 ED63 21 0C EF      		LXI	H,CURPOS
  1415 ED66 FE 7F         		CPI	DEL	;rubouts don't do anything here.
  1416 ED68 C8            		RZ
  1417 ED69 34            		INR	M	;bump line pointer.
  1418 ED6A FE 20         		CPI	' '	;and return if a normal character.
  1419 ED6C D0            		RNC
  1420 ED6D 35            		DCR	M	;restore and check for the start of the line.
  1421 ED6E 7E            		MOV	A,M
  1422 ED6F B7            		ORA	A
  1423 ED70 C8            		RZ		;ingnore control characters at the start of the line.
  1424 ED71 79            		MOV	A,C
  1425 ED72 FE 08         		CPI	BS	;is it a backspace?
  1426 ED74 C2 79 ED      		JNZ	OUTCHR2
  1427 ED77 35            		DCR	M	;yes, backup pointer.
  1428 ED78 C9            		RET
  1429 ED79 FE 0A         	OUTCHR2	CPI	LF	;is it a line feed?
  1430 ED7B C0            		RNZ		;ignore anything else.
  1431 ED7C 36 00         		MVI	M,0	;reset pointer to start of line.
  1432 ED7E C9            		RET
  1433                    	;
  1434                    	;   Output (A) to the screen. If it is a control character
  1435                    	; (other than carriage control), use ^x format.
  1436                    	;
  1437 ED7F 79            	SHOWIT	MOV	A,C
  1438 ED80 CD 14 ED      		CALL	CHKCHAR	;check character.
  1439 ED83 D2 90 ED      		JNC	OUTCON	;not a control, use normal output.
  1440 ED86 F5            		PUSH	PSW
  1441 ED87 0E 5E         		MVI	C,'^'	;for a control character, preceed it with '^'.
  1442 ED89 CD 48 ED      		CALL	OUTCHAR
  1443 ED8C F1            		POP	PSW
  1444 ED8D F6 40         		ORI	'@'	;and then use the letter equivelant.
  1445 ED8F 4F            		MOV	C,A
  1446                    	;
  1447                    	;   Function to output (C) to the console device and expand tabs
  1448                    	; if necessary.
  1449                    	;
  1450 ED90 79            	OUTCON	MOV	A,C
  1451 ED91 FE 09         		CPI	TAB	;is it a tab?
  1452 ED93 C2 48 ED      		JNZ	OUTCHAR	;use regular output.
  1453 ED96 0E 20         	OUTCON1	MVI	C,' '	;yes it is, use spaces instead.
  1454 ED98 CD 48 ED      		CALL	OUTCHAR
  1455 ED9B 3A 0C EF      		LDA	CURPOS	;go until the cursor is at a multiple of 8
  1456                    	
  1457 ED9E E6 07         		ANI	07H	;position.
  1458 EDA0 C2 96 ED      		JNZ	OUTCON1
  1459 EDA3 C9            		RET
  1460                    	;
  1461                    	;   Echo a backspace character. Erase the prevoius character
  1462                    	; on the screen.
  1463                    	;
  1464 EDA4 CD AC ED      	BACKUP	CALL	BACKUP1	;backup the screen 1 place.
  1465 EDA7 0E 20         		MVI	C,' '	;then blank that character.
  1466 EDA9 CD 0C FA      		CALL	CONOUT
  1467 EDAC 0E 08         	BACKUP1	MVI	C,BS	;then back space once more.
  1468 EDAE C3 0C FA      		JMP	CONOUT
  1469                    	;
  1470                    	;   Signal a deleted line. Print a '#' at the end and start
  1471                    	; over.
  1472                    	;
  1473 EDB1 0E 23         	NEWLINE	MVI	C,'#'
  1474 EDB3 CD 48 ED      		CALL	OUTCHAR	;print this.
  1475 EDB6 CD C9 ED      		CALL	OUTCRLF	;start new line.
  1476 EDB9 3A 0C EF      	NEWLN1	LDA	CURPOS	;move the cursor to the starting position.
  1477 EDBC 21 0B EF      		LXI	H,STARTING
  1478 EDBF BE            		CMP	M
  1479 EDC0 D0            		RNC		;there yet?
  1480 EDC1 0E 20         		MVI	C,' '
  1481 EDC3 CD 48 ED      		CALL	OUTCHAR	;nope, keep going.
  1482 EDC6 C3 B9 ED      		JMP	NEWLN1
  1483                    	;
  1484                    	;   Output a (cr) (lf) to the console device (screen).
  1485                    	;
  1486 EDC9 0E 0D         	OUTCRLF	MVI	C,CR
  1487 EDCB CD 48 ED      		CALL	OUTCHAR
  1488 EDCE 0E 0A         		MVI	C,LF
  1489 EDD0 C3 48 ED      		JMP	OUTCHAR
  1490                    	;
  1491                    	;   Print message pointed to by (BC). It will end with a '$'.
  1492                    	;
  1493 EDD3 0A            	PRTMESG	LDAX	B	;check for terminating character.
  1494 EDD4 FE 24         		CPI	'$'
  1495 EDD6 C8            		RZ
  1496 EDD7 03            		INX	B
  1497 EDD8 C5            		PUSH	B	;otherwise, bump pointer and print it.
  1498 EDD9 4F            		MOV	C,A
  1499 EDDA CD 90 ED      		CALL	OUTCON
  1500 EDDD C1            		POP	B
  1501 EDDE C3 D3 ED      		JMP	PRTMESG
  1502                    	;
  1503                    	;   Function to execute a buffered read.
  1504                    	;
  1505 EDE1 3A 0C EF      	RDBUFF	LDA	CURPOS	;use present location as starting one.
  1506 EDE4 32 0B EF      		STA	STARTING
  1507 EDE7 2A 43 EF      		LHLD	PARAMS	;get the maximum buffer space.
  1508 EDEA 4E            		MOV	C,M
  1509 EDEB 23            		INX	H	;point to first available space.
  1510 EDEC E5            		PUSH	H	;and save.
  1511 EDED 06 00         		MVI	B,0	;keep a character count.
  1512 EDEF C5            	RDBUF1	PUSH	B
  1513 EDF0 E5            		PUSH	H
  1514 EDF1 CD FB EC      	RDBUF2	CALL	GETCHAR	;get the next input character.
  1515 EDF4 E6 7F         		ANI	7FH	;strip bit 7.
  1516 EDF6 E1            		POP	H	;reset registers.
  1517 EDF7 C1            		POP	B
  1518 EDF8 FE 0D         		CPI	CR	;en of the line?
  1519 EDFA CA C1 EE      		JZ	RDBUF17
  1520 EDFD FE 0A         		CPI	LF
  1521 EDFF CA C1 EE      		JZ	RDBUF17
  1522 EE02 FE 08         		CPI	BS	;how about a backspace?
  1523 EE04 C2 16 EE      		JNZ	RDBUF3
  1524 EE07 78            		MOV	A,B	;yes, but ignore at the beginning of the line.
  1525 EE08 B7            		ORA	A
  1526 EE09 CA EF ED      		JZ	RDBUF1
  1527 EE0C 05            		DCR	B	;ok, update counter.
  1528 EE0D 3A 0C EF      		LDA	CURPOS	;if we backspace to the start of the line,
  1529 EE10 32 0A EF      		STA	OUTFLAG	;treat as a cancel (control-x).
  1530 EE13 C3 70 EE      		JMP	RDBUF10
  1531 EE16 FE 7F         	RDBUF3	CPI	DEL	;user typed a rubout?
  1532 EE18 C2 26 EE      		JNZ	RDBUF4
  1533 EE1B 78            		MOV	A,B	;ignore at the start of the line.
  1534 EE1C B7            		ORA	A
  1535 EE1D CA EF ED      		JZ	RDBUF1
  1536 EE20 7E            		MOV	A,M	;ok, echo the prevoius character.
  1537 EE21 05            		DCR	B	;and reset pointers (counters).
  1538 EE22 2B            		DCX	H
  1539 EE23 C3 A9 EE      		JMP	RDBUF15
  1540 EE26 FE 05         	RDBUF4	CPI	CNTRLE	;physical end of line?
  1541 EE28 C2 37 EE      		JNZ	RDBUF5
  1542 EE2B C5            		PUSH	B	;yes, do it.
  1543 EE2C E5            		PUSH	H
  1544 EE2D CD C9 ED      		CALL	OUTCRLF
  1545 EE30 AF            		XRA	A	;and update starting position.
  1546 EE31 32 0B EF      		STA	STARTING
  1547 EE34 C3 F1 ED      		JMP	RDBUF2
  1548 EE37 FE 10         	RDBUF5	CPI	CNTRLP	;control-p?
  1549 EE39 C2 48 EE      		JNZ	RDBUF6
  1550 EE3C E5            		PUSH	H	;yes, flip the print flag filp-flop byte.
  1551 EE3D 21 0D EF      		LXI	H,PRTFLAG
  1552 EE40 3E 01         		MVI	A,1	;PRTFLAG=1-PRTFLAG
  1553 EE42 96            		SUB	M
  1554 EE43 77            		MOV	M,A
  1555 EE44 E1            		POP	H
  1556 EE45 C3 EF ED      		JMP	RDBUF1
  1557 EE48 FE 18         	RDBUF6	CPI	CNTRLX	;control-x (cancel)?
  1558 EE4A C2 5F EE      		JNZ	RDBUF8
  1559 EE4D E1            		POP	H
  1560 EE4E 3A 0B EF      	RDBUF7	LDA	STARTING;yes, backup the cursor to here.
  1561 EE51 21 0C EF      		LXI	H,CURPOS
  1562 EE54 BE            		CMP	M
  1563 EE55 D2 E1 ED      		JNC	RDBUFF	;done yet?
  1564 EE58 35            		DCR	M	;no, decrement pointer and output back up one space.
  1565 EE59 CD A4 ED      		CALL	BACKUP
  1566 EE5C C3 4E EE      		JMP	RDBUF7
  1567 EE5F FE 15         	RDBUF8	CPI	CNTRLU	;cntrol-u (cancel line)?
  1568 EE61 C2 6B EE      		JNZ	RDBUF9
  1569 EE64 CD B1 ED      		CALL	NEWLINE	;start a new line.
  1570 EE67 E1            		POP	H
  1571 EE68 C3 E1 ED      		JMP	RDBUFF
  1572 EE6B FE 12         	RDBUF9	CPI	CNTRLR	;control-r?
  1573 EE6D C2 A6 EE      		JNZ	RDBUF14
  1574 EE70 C5            	RDBUF10	PUSH	B	;yes, start a new line and retype the old one.
  1575 EE71 CD B1 ED      		CALL	NEWLINE
  1576 EE74 C1            		POP	B
  1577 EE75 E1            		POP	H
  1578 EE76 E5            		PUSH	H
  1579 EE77 C5            		PUSH	B
  1580 EE78 78            	RDBUF11	MOV	A,B	;done whole line yet?
  1581 EE79 B7            		ORA	A
  1582 EE7A CA 8A EE      		JZ	RDBUF12
  1583 EE7D 23            		INX	H	;nope, get next character.
  1584 EE7E 4E            		MOV	C,M
  1585 EE7F 05            		DCR	B	;count it.
  1586 EE80 C5            		PUSH	B
  1587 EE81 E5            		PUSH	H
  1588 EE82 CD 7F ED      		CALL	SHOWIT	;and display it.
  1589 EE85 E1            		POP	H
  1590 EE86 C1            		POP	B
  1591 EE87 C3 78 EE      		JMP	RDBUF11
  1592 EE8A E5            	RDBUF12	PUSH	H	;done with line. If we were displaying
  1593 EE8B 3A 0A EF      		LDA	OUTFLAG	;then update cursor position.
  1594 EE8E B7            		ORA	A
  1595 EE8F CA F1 ED      		JZ	RDBUF2
  1596 EE92 21 0C EF      		LXI	H,CURPOS;because this line is shorter, we must
  1597 EE95 96            		SUB	M	;back up the cursor (not the screen however)
  1598 EE96 32 0A EF      		STA	OUTFLAG	;some number of positions.
  1599 EE99 CD A4 ED      	RDBUF13	CALL	BACKUP	;note that as long as (OUTFLAG) is non
  1600 EE9C 21 0A EF      		LXI	H,OUTFLAG;zero, the screen will not be changed.
  1601 EE9F 35            		DCR	M
  1602 EEA0 C2 99 EE      		JNZ	RDBUF13
  1603 EEA3 C3 F1 ED      		JMP	RDBUF2	;now just get the next character.
  1604                    	;
  1605                    	;   Just a normal character, put this in our buffer and echo.
  1606                    	;
  1607 EEA6 23            	RDBUF14	INX	H
  1608 EEA7 77            		MOV	M,A	;store character.
  1609 EEA8 04            		INR	B	;and count it.
  1610 EEA9 C5            	RDBUF15	PUSH	B
  1611 EEAA E5            		PUSH	H
  1612 EEAB 4F            		MOV	C,A	;echo it now.
  1613 EEAC CD 7F ED      		CALL	SHOWIT
  1614 EEAF E1            		POP	H
  1615 EEB0 C1            		POP	B
  1616 EEB1 7E            		MOV	A,M	;was it an abort request?
  1617 EEB2 FE 03         		CPI	CNTRLC	;control-c abort?
  1618 EEB4 78            		MOV	A,B
  1619 EEB5 C2 BD EE      		JNZ	RDBUF16
  1620 EEB8 FE 01         		CPI	1	;only if at start of line.
  1621 EEBA CA 00 00      		JZ	0
  1622 EEBD B9            	RDBUF16	CMP	C	;nope, have we filled the buffer?
  1623 EEBE DA EF ED      		JC	RDBUF1
  1624 EEC1 E1            	RDBUF17	POP	H	;yes end the line and return.
  1625 EEC2 70            		MOV	M,B
  1626 EEC3 0E 0D         		MVI	C,CR
  1627 EEC5 C3 48 ED      		JMP	OUTCHAR	;output (cr) and return.
  1628                    	;
  1629                    	;   Function to get a character from the console device.
  1630                    	;
  1631 EEC8 CD 06 ED      	GETCON	CALL	GETECHO	;get and echo.
  1632 EECB C3 01 EF      		JMP	SETSTAT	;save status and return.
  1633                    	;
  1634                    	;   Function to get a character from the tape reader device.
  1635                    	;
  1636 EECE CD 15 FA      	GETRDR	CALL	READER	;get a character from reader, set status and return.
  1637 EED1 C3 01 EF      		JMP	SETSTAT
  1638                    	;
  1639                    	;  Function to perform direct console i/o. If (C) contains (FF)
  1640                    	; then this is an input request. If (C) contains (FE) then
  1641                    	; this is a status request. Otherwise we are to output (C).
  1642                    	;
  1643 EED4 79            	DIRCIO	MOV	A,C	;test for (FF).
  1644 EED5 3C            		INR	A
  1645 EED6 CA E0 EE      		JZ	DIRC1
  1646 EED9 3C            		INR	A	;test for (FE).
  1647 EEDA CA 06 FA      		JZ	CONST
  1648 EEDD C3 0C FA      		JMP	CONOUT	;just output (C).
  1649 EEE0 CD 06 FA      	DIRC1	CALL	CONST	;this is an input request.
  1650 EEE3 B7            		ORA	A
  1651 EEE4 CA 91 F9      		JZ	GOBACK1	;not ready? Just return (directly).
  1652 EEE7 CD 09 FA      		CALL	CONIN	;yes, get character.
  1653 EEEA C3 01 EF      		JMP	SETSTAT	;set status and return.
  1654                    	;
  1655                    	;   Function to return the i/o byte.
  1656                    	;
  1657 EEED 3A 03 00      	GETIOB	LDA	IOBYTE
  1658 EEF0 C3 01 EF      		JMP	SETSTAT
  1659                    	;
  1660                    	;   Function to set the i/o byte.
  1661                    	;
  1662 EEF3 21 03 00      	SETIOB	LXI	H,IOBYTE
  1663 EEF6 71            		MOV	M,C
  1664 EEF7 C9            		RET
  1665                    	;
  1666                    	;   Function to print the character string pointed to by (DE)
  1667                    	; on the console device. The string ends with a '$'.
  1668                    	;
  1669 EEF8 EB            	PRTSTR	XCHG
  1670 EEF9 4D            		MOV	C,L
  1671 EEFA 44            		MOV	B,H	;now (BC) points to it.
  1672 EEFB C3 D3 ED      		JMP	PRTMESG
  1673                    	;
  1674                    	;   Function to interigate the console device.
  1675                    	;
  1676 EEFE CD 23 ED      	GETCSTS	CALL	CKCONSOL
  1677                    	;
  1678                    	;   Get here to set the status and return to the cleanup
  1679                    	; section. Then back to the user.
  1680                    	;
  1681 EF01 32 45 EF      	SETSTAT	STA	STATUS
  1682 EF04 C9            	RTN	RET
  1683                    	;
  1684                    	;   Set the status to 1 (read or write error code).
  1685                    	;
  1686 EF05 3E 01         	IOERR1	MVI	A,1
  1687 EF07 C3 01 EF      		JMP	SETSTAT
  1688                    	;
  1689 EF0A               	OUTFLAG	DB	0	;output flag (non zero means no output).
            00 
  1690 EF0B               	STARTING:DB	2	;starting position for cursor.
            02 
  1691 EF0C               	CURPOS	DB	0	;cursor position (0=start of line).
            00 
  1692 EF0D               	PRTFLAG	DB	0	;printer flag (control-p toggle). List if non zero.
            00 
  1693 EF0E               	CHARBUF	DB	0	;single input character buffer.
            00 
  1694                    	;
  1695                    	;   Stack area for BDOS calls.
  1696                    	;
  1697 EF0F               	USRSTACK:DW	0	;save users stack pointer here.
            00 00 
  1698                    	;
  1699 EF11               		DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
  1700 EF29               		DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
  1701      EF 41         	STKAREA	EQU	$	;end of stack area.
  1702                    	;
  1703 EF41               	USERNO	DB	0	;current user number.
            00 
  1704 EF42               	ACTIVE	DB	0	;currently active drive.
            00 
  1705 EF43               	PARAMS	DW	0	;save (DE) parameters here on entry.
            00 00 
  1706 EF45               	STATUS	DW	0	;status returned from bdos function.
            00 00 
  1707                    	;
  1708                    	;   Select error occured, jump to error routine.
  1709                    	;
  1710 EF47 21 0B EC      	SLCTERR	LXI	H,BADSLCT
  1711                    	;
  1712                    	;   Jump to (HL) indirectly.
  1713                    	;
  1714 EF4A 5E            	JUMPHL	MOV	E,M
  1715 EF4B 23            		INX	H
  1716 EF4C 56            		MOV	D,M	;now (DE) contain the desired address.
  1717 EF4D EB            		XCHG
  1718 EF4E E9            		PCHL
  1719                    	;
  1720                    	;   Block move. (DE) to (HL), (C) bytes total.
  1721                    	;
  1722 EF4F 0C            	DE2HL	INR	C	;is count down to zero?
  1723 EF50 0D            	DE2HL1	DCR	C
  1724 EF51 C8            		RZ		;yes, we are done.
  1725 EF52 1A            		LDAX	D	;no, move one more byte.
  1726 EF53 77            		MOV	M,A
  1727 EF54 13            		INX	D
  1728 EF55 23            		INX	H
  1729 EF56 C3 50 EF      		JMP	DE2HL1	;and repeat.
  1730                    	;
  1731                    	;   Select the desired drive.
  1732                    	;
  1733 EF59 3A 42 EF      	SELECT	LDA	ACTIVE	;get active disk.
  1734 EF5C 4F            		MOV	C,A
  1735 EF5D CD 1B FA      		CALL	SELDSK	;select it.
  1736 EF60 7C            		MOV	A,H	;valid drive?
  1737 EF61 B5            		ORA	L	;valid drive?
  1738 EF62 C8            		RZ		;return if not.
  1739                    	;
  1740                    	;   Here, the BIOS returned the address of the parameter block
  1741                    	; in (HL). We will extract the necessary pointers and save them.
  1742                    	;
  1743 EF63 5E            		MOV	E,M	;yes, get address of translation table into (DE).
  1744 EF64 23            		INX	H
  1745 EF65 56            		MOV	D,M
  1746 EF66 23            		INX	H
  1747 EF67 22 B3 F9      		SHLD	SCRATCH1	;save pointers to scratch areas.
  1748 EF6A 23            		INX	H
  1749 EF6B 23            		INX	H
  1750 EF6C 22 B5 F9      		SHLD	SCRATCH2	;ditto.
  1751 EF6F 23            		INX	H
  1752 EF70 23            		INX	H
  1753 EF71 22 B7 F9      		SHLD	SCRATCH3	;ditto.
  1754 EF74 23            		INX	H
  1755 EF75 23            		INX	H
  1756 EF76 EB            		XCHG		;now save the translation table address.
  1757 EF77 22 D0 F9      		SHLD	XLATE
  1758 EF7A 21 B9 F9      		LXI	H,DIRBUF	;put the next 8 bytes here.
  1759 EF7D 0E 08         		MVI	C,8	;they consist of the directory buffer
  1760 EF7F CD 4F EF      		CALL	DE2HL	;pointer, parameter block pointer,
  1761 EF82 2A BB F9      		LHLD	DISKPB	;check and allocation vectors.
  1762 EF85 EB            		XCHG
  1763 EF86 21 C1 F9      		LXI	H,SECTORS	;move parameter block into our ram.
  1764 EF89 0E 0F         		MVI	C,15	;it is 15 bytes long.
  1765 EF8B CD 4F EF      		CALL	DE2HL
  1766 EF8E 2A C6 F9      		LHLD	DSKSIZE	;check disk size.
  1767 EF91 7C            		MOV	A,H	;more than 256 blocks on this?
  1768 EF92 21 DD F9      		LXI	H,BIGDISK
  1769 EF95 36 FF         		MVI	M,0FFH	;set to samll.
  1770 EF97 B7            		ORA	A
  1771 EF98 CA 9D EF      		JZ	SELECT1
  1772 EF9B 36 00         		MVI	M,0	;wrong, set to large.
  1773 EF9D 3E FF         	SELECT1	MVI	A,0FFH	;clear the zero flag.
  1774 EF9F B7            		ORA	A
  1775 EFA0 C9            		RET
  1776                    	;
  1777                    	;   Routine to home the disk track head and clear pointers.
  1778                    	;
  1779 EFA1 CD 18 FA      	HOMEDRV	CALL	HOME	;home the head.
  1780 EFA4 AF            		XRA	A
  1781 EFA5 2A B5 F9      		LHLD	SCRATCH2;set our track pointer also.
  1782 EFA8 77            		MOV	M,A
  1783 EFA9 23            		INX	H
  1784 EFAA 77            		MOV	M,A
  1785 EFAB 2A B7 F9      		LHLD	SCRATCH3;and our sector pointer.
  1786 EFAE 77            		MOV	M,A
  1787 EFAF 23            		INX	H
  1788 EFB0 77            		MOV	M,A
  1789 EFB1 C9            		RET
  1790                    	;
  1791                    	;   Do the actual disk read and check the error return status.
  1792                    	;
  1793 EFB2 CD 27 FA      	DOREAD	CALL	READ
  1794 EFB5 C3 BB EF      		JMP	IORET
  1795                    	;
  1796                    	;   Do the actual disk write and handle any bios error.
  1797                    	;
  1798 EFB8 CD 2A FA      	DOWRITE	CALL	WRITE
  1799 EFBB B7            	IORET	ORA	A
  1800 EFBC C8            		RZ		;return unless an error occured.
  1801 EFBD 21 09 EC      		LXI	H,BADSCTR;bad read/write on this sector.
  1802 EFC0 C3 4A EF      		JMP	JUMPHL
  1803                    	;
  1804                    	;   Routine to select the track and sector that the desired
  1805                    	; block number falls in.
  1806                    	;
  1807 EFC3 2A EA F9      	TRKSEC	LHLD	FILEPOS	;get position of last accessed file
  1808 EFC6 0E 02         		MVI	C,2	;in directory and compute sector #.
  1809 EFC8 CD EA F0      		CALL	SHIFTR	;sector #=file-position/4.
  1810 EFCB 22 E5 F9      		SHLD	BLKNMBR	;save this as the block number of interest.
  1811 EFCE 22 EC F9      		SHLD	CKSUMTBL;what's it doing here too?
  1812                    	;
  1813                    	;   if the sector number has already been set (BLKNMBR), enter
  1814                    	; at this point.
  1815                    	;
  1816 EFD1 21 E5 F9      	TRKSEC1	LXI	H,BLKNMBR
  1817 EFD4 4E            		MOV	C,M	;move sector number into (BC).
  1818 EFD5 23            		INX	H
  1819 EFD6 46            		MOV	B,M
  1820 EFD7 2A B7 F9      		LHLD	SCRATCH3;get current sector number and
  1821 EFDA 5E            		MOV	E,M	;move this into (DE).
  1822 EFDB 23            		INX	H
  1823 EFDC 56            		MOV	D,M
  1824 EFDD 2A B5 F9      		LHLD	SCRATCH2;get current track number.
  1825 EFE0 7E            		MOV	A,M	;and this into (HL).
  1826 EFE1 23            		INX	H
  1827 EFE2 66            		MOV	H,M
  1828 EFE3 6F            		MOV	L,A
  1829 EFE4 79            	TRKSEC2	MOV	A,C	;is desired sector before current one?
  1830 EFE5 93            		SUB	E
  1831 EFE6 78            		MOV	A,B
  1832 EFE7 9A            		SBB	D
  1833 EFE8 D2 FA EF      		JNC	TRKSEC3
  1834 EFEB E5            		PUSH	H	;yes, decrement sectors by one track.
  1835 EFEC 2A C1 F9      		LHLD	SECTORS	;get sectors per track.
  1836 EFEF 7B            		MOV	A,E
  1837 EFF0 95            		SUB	L
  1838 EFF1 5F            		MOV	E,A
  1839 EFF2 7A            		MOV	A,D
  1840 EFF3 9C            		SBB	H
  1841 EFF4 57            		MOV	D,A	;now we have backed up one full track.
  1842 EFF5 E1            		POP	H
  1843 EFF6 2B            		DCX	H	;adjust track counter.
  1844 EFF7 C3 E4 EF      		JMP	TRKSEC2
  1845 EFFA E5            	TRKSEC3	PUSH	H	;desired sector is after current one.
  1846 EFFB 2A C1 F9      		LHLD	SECTORS	;get sectors per track.
  1847 EFFE 19            		DAD	D	;bump sector pointer to next track.
  1848 EFFF DA 0F F0      		JC	TRKSEC4
  1849 F002 79            		MOV	A,C	;is desired sector now before current one?
  1850 F003 95            		SUB	L
  1851 F004 78            		MOV	A,B
  1852 F005 9C            		SBB	H
  1853 F006 DA 0F F0      		JC	TRKSEC4
  1854 F009 EB            		XCHG		;not yes, increment track counter
  1855 F00A E1            		POP	H	;and continue until it is.
  1856 F00B 23            		INX	H
  1857 F00C C3 FA EF      		JMP	TRKSEC3
  1858                    	;
  1859                    	;   here we have determined the track number that contains the
  1860                    	; desired sector.
  1861                    	;
  1862 F00F E1            	TRKSEC4	POP	H	;get track number (HL).
  1863 F010 C5            		PUSH	B
  1864 F011 D5            		PUSH	D
  1865 F012 E5            		PUSH	H
  1866 F013 EB            		XCHG
  1867 F014 2A CE F9      		LHLD	OFFSET	;adjust for first track offset.
  1868 F017 19            		DAD	D
  1869 F018 44            		MOV	B,H
  1870 F019 4D            		MOV	C,L
  1871 F01A CD 1E FA      		CALL	SETTRK	;select this track.
  1872 F01D D1            		POP	D	;reset current track pointer.
  1873 F01E 2A B5 F9      		LHLD	SCRATCH2
  1874 F021 73            		MOV	M,E
  1875 F022 23            		INX	H
  1876 F023 72            		MOV	M,D
  1877 F024 D1            		POP	D
  1878 F025 2A B7 F9      		LHLD	SCRATCH3;reset the first sector on this track.
  1879 F028 73            		MOV	M,E
  1880 F029 23            		INX	H
  1881 F02A 72            		MOV	M,D
  1882 F02B C1            		POP	B
  1883 F02C 79            		MOV	A,C	;now subtract the desired one.
  1884 F02D 93            		SUB	E	;to make it relative (1-# sectors/track).
  1885 F02E 4F            		MOV	C,A
  1886 F02F 78            		MOV	A,B
  1887 F030 9A            		SBB	D
  1888 F031 47            		MOV	B,A
  1889 F032 2A D0 F9      		LHLD	XLATE	;translate this sector according to this table.
  1890 F035 EB            		XCHG
  1891 F036 CD 30 FA      		CALL	SECTRN	;let the bios translate it.
  1892 F039 4D            		MOV	C,L
  1893 F03A 44            		MOV	B,H
  1894 F03B C3 21 FA      		JMP	SETSEC	;and select it.
  1895                    	;
  1896                    	;   Compute block number from record number (SAVNREC) and
  1897                    	; extent number (SAVEXT).
  1898                    	;
  1899 F03E 21 C3 F9      	GETBLOCK:LXI	H,BLKSHFT;get logical to physical conversion.
  1900 F041 4E            		MOV	C,M	;note that this is base 2 log of ratio.
  1901 F042 3A E3 F9      		LDA	SAVNREC	;get record number.
  1902 F045 B7            	GETBLK1	ORA	A	;compute (A)=(A)/2^BLKSHFT.
  1903 F046 1F            		RAR
  1904 F047 0D            		DCR	C
  1905 F048 C2 45 F0      		JNZ	GETBLK1
  1906 F04B 47            		MOV	B,A	;save result in (B).
  1907 F04C 3E 08         		MVI	A,8
  1908 F04E 96            		SUB	M
  1909 F04F 4F            		MOV	C,A	;compute (C)=8-BLKSHFT.
  1910 F050 3A E2 F9      		LDA	SAVEXT
  1911 F053 0D            	GETBLK2	DCR	C	;compute (A)=SAVEXT*2^(8-BLKSHFT).
  1912 F054 CA 5C F0      		JZ	GETBLK3
  1913 F057 B7            		ORA	A
  1914 F058 17            		RAL
  1915 F059 C3 53 F0      		JMP	GETBLK2
  1916 F05C 80            	GETBLK3	ADD	B
  1917 F05D C9            		RET
  1918                    	;
  1919                    	;   Routine to extract the (BC) block byte from the fcb pointed
  1920                    	; to by (PARAMS). If this is a big-disk, then these are 16 bit
  1921                    	; block numbers, else they are 8 bit numbers.
  1922                    	; Number is returned in (HL).
  1923                    	;
  1924 F05E 2A 43 EF      	EXTBLK	LHLD	PARAMS	;get fcb address.
  1925 F061 11 10 00      		LXI	D,16	;block numbers start 16 bytes into fcb.
  1926 F064 19            		DAD	D
  1927 F065 09            		DAD	B
  1928 F066 3A DD F9      		LDA	BIGDISK	;are we using a big-disk?
  1929 F069 B7            		ORA	A
  1930 F06A CA 71 F0      		JZ	EXTBLK1
  1931 F06D 6E            		MOV	L,M	;no, extract an 8 bit number from the fcb.
  1932 F06E 26 00         		MVI	H,0
  1933 F070 C9            		RET
  1934 F071 09            	EXTBLK1	DAD	B	;yes, extract a 16 bit number.
  1935 F072 5E            		MOV	E,M
  1936 F073 23            		INX	H
  1937 F074 56            		MOV	D,M
  1938 F075 EB            		XCHG		;return in (HL).
  1939 F076 C9            		RET
  1940                    	;
  1941                    	;   Compute block number.
  1942                    	;
  1943 F077 CD 3E F0      	COMBLK	CALL	GETBLOCK
  1944 F07A 4F            		MOV	C,A
  1945 F07B 06 00         		MVI	B,0
  1946 F07D CD 5E F0      		CALL	EXTBLK
  1947 F080 22 E5 F9      		SHLD	BLKNMBR
  1948 F083 C9            		RET
  1949                    	;
  1950                    	;   Check for a zero block number (unused).
  1951                    	;
  1952 F084 2A E5 F9      	CHKBLK	LHLD	BLKNMBR
  1953 F087 7D            		MOV	A,L	;is it zero?
  1954 F088 B4            		ORA	H
  1955 F089 C9            		RET
  1956                    	;
  1957                    	;   Adjust physical block (BLKNMBR) and convert to logical
  1958                    	; sector (LOGSECT). This is the starting sector of this block.
  1959                    	; The actual sector of interest is then added to this and the
  1960                    	; resulting sector number is stored back in (BLKNMBR). This
  1961                    	; will still have to be adjusted for the track number.
  1962                    	;
  1963 F08A 3A C3 F9      	LOGICAL	LDA	BLKSHFT	;get log2(physical/logical sectors).
  1964 F08D 2A E5 F9      		LHLD	BLKNMBR	;get physical sector desired.
  1965 F090 29            	LOGICL1	DAD	H	;compute logical sector number.
  1966 F091 3D            		DCR	A	;note logical sectors are 128 bytes long.
  1967 F092 C2 90 F0      		JNZ	LOGICL1
  1968 F095 22 E7 F9      		SHLD	LOGSECT	;save logical sector.
  1969 F098 3A C4 F9      		LDA	BLKMASK	;get block mask.
  1970 F09B 4F            		MOV	C,A
  1971 F09C 3A E3 F9      		LDA	SAVNREC	;get next sector to access.
  1972 F09F A1            		ANA	C	;extract the relative position within physical block.
  1973 F0A0 B5            		ORA	L	;and add it too logical sector.
  1974 F0A1 6F            		MOV	L,A
  1975 F0A2 22 E5 F9      		SHLD	BLKNMBR	;and store.
  1976 F0A5 C9            		RET
  1977                    	;
  1978                    	;   Set (HL) to point to extent byte in fcb.
  1979                    	;
  1980 F0A6 2A 43 EF      	SETEXT	LHLD	PARAMS
  1981 F0A9 11 0C 00      		LXI	D,12	;it is the twelth byte.
  1982 F0AC 19            		DAD	D
  1983 F0AD C9            		RET
  1984                    	;
  1985                    	;   Set (HL) to point to record count byte in fcb and (DE) to
  1986                    	; next record number byte.
  1987                    	;
  1988 F0AE 2A 43 EF      	SETHLDE	LHLD	PARAMS
  1989 F0B1 11 0F 00      		LXI	D,15	;record count byte (#15).
  1990 F0B4 19            		DAD	D
  1991 F0B5 EB            		XCHG
  1992 F0B6 21 11 00      		LXI	H,17	;next record number (#32).
  1993 F0B9 19            		DAD	D
  1994 F0BA C9            		RET
  1995                    	;
  1996                    	;   Save current file data from fcb.
  1997                    	;
  1998 F0BB CD AE F0      	STRDATA	CALL	SETHLDE
  1999 F0BE 7E            		MOV	A,M	;get and store record count byte.
  2000 F0BF 32 E3 F9      		STA	SAVNREC
  2001 F0C2 EB            		XCHG
  2002 F0C3 7E            		MOV	A,M	;get and store next record number byte.
  2003 F0C4 32 E1 F9      		STA	SAVNXT
  2004 F0C7 CD A6 F0      		CALL	SETEXT	;point to extent byte.
  2005 F0CA 3A C5 F9      		LDA	EXTMASK	;get extent mask.
  2006 F0CD A6            		ANA	M
  2007 F0CE 32 E2 F9      		STA	SAVEXT	;and save extent here.
  2008 F0D1 C9            		RET
  2009                    	;
  2010                    	;   Set the next record to access. If (MODE) is set to 2, then
  2011                    	; the last record byte (SAVNREC) has the correct number to access.
  2012                    	; For sequential access, (MODE) will be equal to 1.
  2013                    	;
  2014 F0D2 CD AE F0      	SETNREC	CALL	SETHLDE
  2015 F0D5 3A D5 F9      		LDA	MODE	;get sequential flag (=1).
  2016 F0D8 FE 02         		CPI	2	;a 2 indicates that no adder is needed.
  2017 F0DA C2 DE F0      		JNZ	STNREC1
  2018 F0DD AF            		XRA	A	;clear adder (random access?).
  2019 F0DE 4F            	STNREC1	MOV	C,A
  2020 F0DF 3A E3 F9      		LDA	SAVNREC	;get last record number.
  2021 F0E2 81            		ADD	C	;increment record count.
  2022 F0E3 77            		MOV	M,A	;and set fcb's next record byte.
  2023 F0E4 EB            		XCHG
  2024 F0E5 3A E1 F9      		LDA	SAVNXT	;get next record byte from storage.
  2025 F0E8 77            		MOV	M,A	;and put this into fcb as number of records used.
  2026 F0E9 C9            		RET
  2027                    	;
  2028                    	;   Shift (HL) right (C) bits.
  2029                    	;
  2030 F0EA 0C            	SHIFTR	INR	C
  2031 F0EB 0D            	SHIFTR1	DCR	C
  2032 F0EC C8            		RZ
  2033 F0ED 7C            		MOV	A,H
  2034 F0EE B7            		ORA	A
  2035 F0EF 1F            		RAR
  2036 F0F0 67            		MOV	H,A
  2037 F0F1 7D            		MOV	A,L
  2038 F0F2 1F            		RAR
  2039 F0F3 6F            		MOV	L,A
  2040 F0F4 C3 EB F0      		JMP	SHIFTR1
  2041                    	;
  2042                    	;   Compute the check-sum for the directory buffer. Return
  2043                    	; integer sum in (A).
  2044                    	;
  2045 F0F7 0E 80         	CHECKSUM:MVI	C,128	;length of buffer.
  2046 F0F9 2A B9 F9      		LHLD	DIRBUF	;get its location.
  2047 F0FC AF            		XRA	A	;clear summation byte.
  2048 F0FD 86            	CHKSUM1	ADD	M	;and compute sum ignoring carries.
  2049 F0FE 23            		INX	H
  2050 F0FF 0D            		DCR	C
  2051 F100 C2 FD F0      		JNZ	CHKSUM1
  2052 F103 C9            		RET
  2053                    	;
  2054                    	;   Shift (HL) left (C) bits.
  2055                    	;
  2056 F104 0C            	SHIFTL	INR	C
  2057 F105 0D            	SHIFTL1	DCR	C
  2058 F106 C8            		RZ
  2059 F107 29            		DAD	H	;shift left 1 bit.
  2060 F108 C3 05 F1      		JMP	SHIFTL1
  2061                    	;
  2062                    	;   Routine to set a bit in a 16 bit value contained in (BC).
  2063                    	; The bit set depends on the current drive selection.
  2064                    	;
  2065 F10B C5            	SETBIT	PUSH	B	;save 16 bit word.
  2066 F10C 3A 42 EF      		LDA	ACTIVE	;get active drive.
  2067 F10F 4F            		MOV	C,A
  2068 F110 21 01 00      		LXI	H,1
  2069 F113 CD 04 F1      		CALL	SHIFTL	;shift bit 0 into place.
  2070 F116 C1            		POP	B	;now 'or' this with the original word.
  2071 F117 79            		MOV	A,C
  2072 F118 B5            		ORA	L
  2073 F119 6F            		MOV	L,A	;low byte done, do high byte.
  2074 F11A 78            		MOV	A,B
  2075 F11B B4            		ORA	H
  2076 F11C 67            		MOV	H,A
  2077 F11D C9            		RET
  2078                    	;
  2079                    	;   Extract the write protect status bit for the current drive.
  2080                    	; The result is returned in (A), bit 0.
  2081                    	;
  2082 F11E 2A AD F9      	GETWPRT	LHLD	WRTPRT	;get status bytes.
  2083 F121 3A 42 EF      		LDA	ACTIVE	;which drive is current?
  2084 F124 4F            		MOV	C,A
  2085 F125 CD EA F0      		CALL	SHIFTR	;shift status such that bit 0 is the
  2086 F128 7D            		MOV	A,L	;one of interest for this drive.
  2087 F129 E6 01         		ANI	01H	;and isolate it.
  2088 F12B C9            		RET
  2089                    	;
  2090                    	;   Function to write protect the current disk.
  2091                    	;
  2092 F12C 21 AD F9      	WRTPRTD	LXI	H,WRTPRT;point to status word.
  2093 F12F 4E            		MOV	C,M	;set (BC) equal to the status.
  2094 F130 23            		INX	H
  2095 F131 46            		MOV	B,M
  2096 F132 CD 0B F1      		CALL	SETBIT	;and set this bit according to current drive.
  2097 F135 22 AD F9      		SHLD	WRTPRT	;then save.
  2098 F138 2A C8 F9      		LHLD	DIRSIZE	;now save directory size limit.
  2099 F13B 23            		INX	H	;remember the last one.
  2100 F13C EB            		XCHG
  2101 F13D 2A B3 F9      		LHLD	SCRATCH1;and store it here.
  2102 F140 73            		MOV	M,E	;put low byte.
  2103 F141 23            		INX	H
  2104 F142 72            		MOV	M,D	;then high byte.
  2105 F143 C9            		RET
  2106                    	;
  2107                    	;   Check for a read only file.
  2108                    	;
  2109 F144 CD 5E F1      	CHKROFL	CALL	FCB2HL	;set (HL) to file entry in directory buffer.
  2110 F147 11 09 00      	CKROF1	LXI	D,9	;look at bit 7 of the ninth byte.
  2111 F14A 19            		DAD	D
  2112 F14B 7E            		MOV	A,M
  2113 F14C 17            		RAL
  2114 F14D D0            		RNC		;return if ok.
  2115 F14E 21 0F EC      		LXI	H,ROFILE;else, print error message and terminate.
  2116 F151 C3 4A EF      		JMP	JUMPHL
  2117                    	;
  2118                    	;   Check the write protect status of the active disk.
  2119                    	;
  2120 F154 CD 1E F1      	CHKWPRT	CALL	GETWPRT
  2121 F157 C8            		RZ		;return if ok.
  2122 F158 21 0D EC      		LXI	H,RODISK;else print message and terminate.
  2123 F15B C3 4A EF      		JMP	JUMPHL
  2124                    	;
  2125                    	;   Routine to set (HL) pointing to the proper entry in the
  2126                    	; directory buffer.
  2127                    	;
  2128 F15E 2A B9 F9      	FCB2HL	LHLD	DIRBUF	;get address of buffer.
  2129 F161 3A E9 F9      		LDA	FCBPOS	;relative position of file.
  2130                    	;
  2131                    	;   Routine to add (A) to (HL).
  2132                    	;
  2133 F164 85            	ADDA2HL	ADD	L
  2134 F165 6F            		MOV	L,A
  2135 F166 D0            		RNC
  2136 F167 24            		INR	H	;take care of any carry.
  2137 F168 C9            		RET
  2138                    	;
  2139                    	;   Routine to get the 's2' byte from the fcb supplied in
  2140                    	; the initial parameter specification.
  2141                    	;
  2142 F169 2A 43 EF      	GETS2	LHLD	PARAMS	;get address of fcb.
  2143 F16C 11 0E 00      		LXI	D,14	;relative position of 's2'.
  2144 F16F 19            		DAD	D
  2145 F170 7E            		MOV	A,M	;extract this byte.
  2146 F171 C9            		RET
  2147                    	;
  2148                    	;   Clear the 's2' byte in the fcb.
  2149                    	;
  2150 F172 CD 69 F1      	CLEARS2	CALL	GETS2	;this sets (HL) pointing to it.
  2151 F175 36 00         		MVI	M,0	;now clear it.
  2152 F177 C9            		RET
  2153                    	;
  2154                    	;   Set bit 7 in the 's2' byte of the fcb.
  2155                    	;
  2156 F178 CD 69 F1      	SETS2B7	CALL	GETS2	;get the byte.
  2157 F17B F6 80         		ORI	80H	;and set bit 7.
  2158 F17D 77            		MOV	M,A	;then store.
  2159 F17E C9            		RET
  2160                    	;
  2161                    	;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
  2162                    	; the difference. This checks to see if there are more file
  2163                    	; names in the directory. We are at (FILEPOS) and there are
  2164                    	; (SCRATCH1) of them to check.
  2165                    	;
  2166 F17F 2A EA F9      	MOREFLS	LHLD	FILEPOS	;we are here.
  2167 F182 EB            		XCHG
  2168 F183 2A B3 F9      		LHLD	SCRATCH1;and don't go past here.
  2169 F186 7B            		MOV	A,E	;compute difference but don't keep.
  2170 F187 96            		SUB	M
  2171 F188 23            		INX	H
  2172 F189 7A            		MOV	A,D
  2173 F18A 9E            		SBB	M	;set carry if no more names.
  2174 F18B C9            		RET
  2175                    	;
  2176                    	;   Call this routine to prevent (SCRATCH1) from being greater
  2177                    	; than (FILEPOS).
  2178                    	;
  2179 F18C CD 7F F1      	CHKNMBR	CALL	MOREFLS	;SCRATCH1 too big?
  2180 F18F D8            		RC
  2181 F190 13            		INX	D	;yes, reset it to (FILEPOS).
  2182 F191 72            		MOV	M,D
  2183 F192 2B            		DCX	H
  2184 F193 73            		MOV	M,E
  2185 F194 C9            		RET
  2186                    	;
  2187                    	;   Compute (HL)=(DE)-(HL)
  2188                    	;
  2189 F195 7B            	SUBHL	MOV	A,E	;compute difference.
  2190 F196 95            		SUB	L
  2191 F197 6F            		MOV	L,A	;store low byte.
  2192 F198 7A            		MOV	A,D
  2193 F199 9C            		SBB	H
  2194 F19A 67            		MOV	H,A	;and then high byte.
  2195 F19B C9            		RET
  2196                    	;
  2197                    	;   Set the directory checksum byte.
  2198                    	;
  2199 F19C 0E FF         	SETDIR	MVI	C,0FFH
  2200                    	;
  2201                    	;   Routine to set or compare the directory checksum byte. If
  2202                    	; (C)=0ffh, then this will set the checksum byte. Else the byte
  2203                    	; will be checked. If the check fails (the disk has been changed),
  2204                    	; then this disk will be write protected.
  2205                    	;
  2206 F19E 2A EC F9      	CHECKDIR:LHLD	CKSUMTBL
  2207 F1A1 EB            		XCHG
  2208 F1A2 2A CC F9      		LHLD	ALLOC1
  2209 F1A5 CD 95 F1      		CALL	SUBHL
  2210 F1A8 D0            		RNC		;ok if (CKSUMTBL) > (ALLOC1), so return.
  2211 F1A9 C5            		PUSH	B
  2212 F1AA CD F7 F0      		CALL	CHECKSUM;else compute checksum.
  2213 F1AD 2A BD F9      		LHLD	CHKVECT	;get address of checksum table.
  2214 F1B0 EB            		XCHG
  2215 F1B1 2A EC F9      		LHLD	CKSUMTBL
  2216 F1B4 19            		DAD	D	;set (HL) to point to byte for this drive.
  2217 F1B5 C1            		POP	B
  2218 F1B6 0C            		INR	C	;set or check ?
  2219 F1B7 CA C4 F1      		JZ	CHKDIR1
  2220 F1BA BE            		CMP	M	;check them.
  2221 F1BB C8            		RZ		;return if they are the same.
  2222 F1BC CD 7F F1      		CALL	MOREFLS	;not the same, do we care?
  2223 F1BF D0            		RNC
  2224 F1C0 CD 2C F1      		CALL	WRTPRTD	;yes, mark this as write protected.
  2225 F1C3 C9            		RET
  2226 F1C4 77            	CHKDIR1	MOV	M,A	;just set the byte.
  2227 F1C5 C9            		RET
  2228                    	;
  2229                    	;   Do a write to the directory of the current disk.
  2230                    	;
  2231 F1C6 CD 9C F1      	DIRWRITE:CALL	SETDIR	;set checksum byte.
  2232 F1C9 CD E0 F1      		CALL	DIRDMA	;set directory dma address.
  2233 F1CC 0E 01         		MVI	C,1	;tell the bios to actually write.
  2234 F1CE CD B8 EF      		CALL	DOWRITE	;then do the write.
  2235 F1D1 C3 DA F1      		JMP	DEFDMA
  2236                    	;
  2237                    	;   Read from the directory.
  2238                    	;
  2239 F1D4 CD E0 F1      	DIRREAD	CALL	DIRDMA	;set the directory dma address.
  2240 F1D7 CD B2 EF      		CALL	DOREAD	;and read it.
  2241                    	;
  2242                    	;   Routine to set the dma address to the users choice.
  2243                    	;
  2244 F1DA 21 B1 F9      	DEFDMA	LXI	H,USERDMA;reset the default dma address and return.
  2245 F1DD C3 E3 F1      		JMP	DIRDMA1
  2246                    	;
  2247                    	;   Routine to set the dma address for directory work.
  2248                    	;
  2249 F1E0 21 B9 F9      	DIRDMA	LXI	H,DIRBUF
  2250                    	;
  2251                    	;   Set the dma address. On entry, (HL) points to
  2252                    	; word containing the desired dma address.
  2253                    	;
  2254 F1E3 4E            	DIRDMA1	MOV	C,M
  2255 F1E4 23            		INX	H
  2256 F1E5 46            		MOV	B,M	;setup (BC) and go to the bios to set it.
  2257 F1E6 C3 24 FA      		JMP	SETDMA
  2258                    	;
  2259                    	;   Move the directory buffer into user's dma space.
  2260                    	;
  2261 F1E9 2A B9 F9      	MOVEDIR	LHLD	DIRBUF	;buffer is located here, and
  2262 F1EC EB            		XCHG
  2263 F1ED 2A B1 F9      		LHLD	USERDMA; put it here.
  2264 F1F0 0E 80         		MVI	C,128	;this is its length.
  2265 F1F2 C3 4F EF      		JMP	DE2HL	;move it now and return.
  2266                    	;
  2267                    	;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
  2268                    	;
  2269 F1F5 21 EA F9      	CKFILPOS:LXI	H,FILEPOS
  2270 F1F8 7E            		MOV	A,M
  2271 F1F9 23            		INX	H
  2272 F1FA BE            		CMP	M	;are both bytes the same?
  2273 F1FB C0            		RNZ
  2274 F1FC 3C            		INR	A	;yes, but are they each 0ffh?
  2275 F1FD C9            		RET
  2276                    	;
  2277                    	;   Set location (FILEPOS) to 0ffffh.
  2278                    	;
  2279 F1FE 21 FF FF      	STFILPOS:LXI	H,0FFFFH
  2280 F201 22 EA F9      		SHLD	FILEPOS
  2281 F204 C9            		RET
  2282                    	;
  2283                    	;   Move on to the next file position within the current
  2284                    	; directory buffer. If no more exist, set pointer to 0ffffh
  2285                    	; and the calling routine will check for this. Enter with (C)
  2286                    	; equal to 0ffh to cause the checksum byte to be set, else we
  2287                    	; will check this disk and set write protect if checksums are
  2288                    	; not the same (applies only if another directory sector must
  2289                    	; be read).
  2290                    	;
  2291 F205 2A C8 F9      	NXENTRY	LHLD	DIRSIZE	;get directory entry size limit.
  2292 F208 EB            		XCHG
  2293 F209 2A EA F9      		LHLD	FILEPOS	;get current count.
  2294 F20C 23            		INX	H	;go on to the next one.
  2295 F20D 22 EA F9      		SHLD	FILEPOS
  2296 F210 CD 95 F1      		CALL	SUBHL	;(HL)=(DIRSIZE)-(FILEPOS)
  2297 F213 D2 19 F2      		JNC	NXENT1	;is there more room left?
  2298 F216 C3 FE F1      		JMP	STFILPOS;no. Set this flag and return.
  2299 F219 3A EA F9      	NXENT1	LDA	FILEPOS	;get file position within directory.
  2300 F21C E6 03         		ANI	03H	;only look within this sector (only 4 entries fit).
  2301 F21E 06 05         		MVI	B,5	;convert to relative position (32 bytes each).
  2302 F220 87            	NXENT2	ADD	A	;note that this is not efficient code.
  2303 F221 05            		DCR	B	;5 'ADD A's would be better.
  2304 F222 C2 20 F2      		JNZ	NXENT2
  2305 F225 32 E9 F9      		STA	FCBPOS	;save it as position of fcb.
  2306 F228 B7            		ORA	A
  2307 F229 C0            		RNZ		;return if we are within buffer.
  2308 F22A C5            		PUSH	B
  2309 F22B CD C3 EF      		CALL	TRKSEC	;we need the next directory sector.
  2310 F22E CD D4 F1      		CALL	DIRREAD
  2311 F231 C1            		POP	B
  2312 F232 C3 9E F1      		JMP	CHECKDIR
  2313                    	;
  2314                    	;   Routine to to get a bit from the disk space allocation
  2315                    	; map. It is returned in (A), bit position 0. On entry to here,
  2316                    	; set (BC) to the block number on the disk to check.
  2317                    	; On return, (D) will contain the original bit position for
  2318                    	; this block number and (HL) will point to the address for it.
  2319                    	;
  2320 F235 79            	CKBITMAP:MOV	A,C	;determine bit number of interest.
  2321 F236 E6 07         		ANI	07H	;compute (D)=(E)=(C and 7)+1.
  2322 F238 3C            		INR	A
  2323 F239 5F            		MOV	E,A	;save particular bit number.
  2324 F23A 57            		MOV	D,A
  2325                    	;
  2326                    	;   compute (BC)=(BC)/8.
  2327                    	;
  2328 F23B 79            		MOV	A,C
  2329 F23C 0F            		RRC		;now shift right 3 bits.
  2330 F23D 0F            		RRC
  2331 F23E 0F            		RRC
  2332 F23F E6 1F         		ANI	1FH	;and clear bits 7,6,5.
  2333 F241 4F            		MOV	C,A
  2334 F242 78            		MOV	A,B
  2335 F243 87            		ADD	A	;now shift (B) into bits 7,6,5.
  2336 F244 87            		ADD	A
  2337 F245 87            		ADD	A
  2338 F246 87            		ADD	A
  2339 F247 87            		ADD	A
  2340 F248 B1            		ORA	C	;and add in (C).
  2341 F249 4F            		MOV	C,A	;ok, (C) ha been completed.
  2342 F24A 78            		MOV	A,B	;is there a better way of doing this?
  2343 F24B 0F            		RRC
  2344 F24C 0F            		RRC
  2345 F24D 0F            		RRC
  2346 F24E E6 1F         		ANI	1FH
  2347 F250 47            		MOV	B,A	;and now (B) is completed.
  2348                    	;
  2349                    	;   use this as an offset into the disk space allocation
  2350                    	; table.
  2351                    	;
  2352 F251 2A BF F9      		LHLD	ALOCVECT
  2353 F254 09            		DAD	B
  2354 F255 7E            		MOV	A,M	;now get correct byte.
  2355 F256 07            	CKBMAP1	RLC		;get correct bit into position 0.
  2356 F257 1D            		DCR	E
  2357 F258 C2 56 F2      		JNZ	CKBMAP1
  2358 F25B C9            		RET
  2359                    	;
  2360                    	;   Set or clear the bit map such that block number (BC) will be marked
  2361                    	; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
  2362                    	; 1 then it will be set (don't use anyother values).
  2363                    	;
  2364 F25C D5            	STBITMAP:PUSH	D
  2365 F25D CD 35 F2      		CALL	CKBITMAP;get the byte of interest.
  2366 F260 E6 FE         		ANI	0FEH	;clear the affected bit.
  2367 F262 C1            		POP	B
  2368 F263 B1            		ORA	C	;and now set it acording to (C).
  2369                    	;
  2370                    	;  entry to restore the original bit position and then store
  2371                    	; in table. (A) contains the value, (D) contains the bit
  2372                    	; position (1-8), and (HL) points to the address within the
  2373                    	; space allocation table for this byte.
  2374                    	;
  2375 F264 0F            	STBMAP1	RRC		;restore original bit position.
  2376 F265 15            		DCR	D
  2377 F266 C2 64 F2      		JNZ	STBMAP1
  2378 F269 77            		MOV	M,A	;and stor byte in table.
  2379 F26A C9            		RET
  2380                    	;
  2381                    	;   Set/clear space used bits in allocation map for this file.
  2382                    	; On entry, (C)=1 to set the map and (C)=0 to clear it.
  2383                    	;
  2384 F26B CD 5E F1      	SETFILE	CALL	FCB2HL	;get address of fcb
  2385 F26E 11 10 00      		LXI	D,16
  2386 F271 19            		DAD	D	;get to block number bytes.
  2387 F272 C5            		PUSH	B
  2388 F273 0E 11         		MVI	C,17	;check all 17 bytes (max) of table.
  2389 F275 D1            	SETFL1	POP	D
  2390 F276 0D            		DCR	C	;done all bytes yet?
  2391 F277 C8            		RZ
  2392 F278 D5            		PUSH	D
  2393 F279 3A DD F9      		LDA	BIGDISK	;check disk size for 16 bit block numbers.
  2394 F27C B7            		ORA	A
  2395 F27D CA 88 F2      		JZ	SETFL2
  2396 F280 C5            		PUSH	B	;only 8 bit numbers. set (BC) to this one.
  2397 F281 E5            		PUSH	H
  2398 F282 4E            		MOV	C,M	;get low byte from table, always
  2399 F283 06 00         		MVI	B,0	;set high byte to zero.
  2400 F285 C3 8E F2      		JMP	SETFL3
  2401 F288 0D            	SETFL2	DCR	C	;for 16 bit block numbers, adjust counter.
  2402 F289 C5            		PUSH	B
  2403 F28A 4E            		MOV	C,M	;now get both the low and high bytes.
  2404 F28B 23            		INX	H
  2405 F28C 46            		MOV	B,M
  2406 F28D E5            		PUSH	H
  2407 F28E 79            	SETFL3	MOV	A,C	;block used?
  2408 F28F B0            		ORA	B
  2409 F290 CA 9D F2      		JZ	SETFL4
  2410 F293 2A C6 F9      		LHLD	DSKSIZE	;is this block number within the
  2411 F296 7D            		MOV	A,L	;space on the disk?
  2412 F297 91            		SUB	C
  2413 F298 7C            		MOV	A,H
  2414 F299 98            		SBB	B
  2415 F29A D4 5C F2      		CNC	STBITMAP;yes, set the proper bit.
  2416 F29D E1            	SETFL4	POP	H	;point to next block number in fcb.
  2417 F29E 23            		INX	H
  2418 F29F C1            		POP	B
  2419 F2A0 C3 75 F2      		JMP	SETFL1
  2420                    	;
  2421                    	;   Construct the space used allocation bit map for the active
  2422                    	; drive. If a file name starts with '$' and it is under the
  2423                    	; current user number, then (STATUS) is set to minus 1. Otherwise
  2424                    	; it is not set at all.
  2425                    	;
  2426 F2A3 2A C6 F9      	BITMAP	LHLD	DSKSIZE	;compute size of allocation table.
  2427 F2A6 0E 03         		MVI	C,3
  2428 F2A8 CD EA F0      		CALL	SHIFTR	;(HL)=(HL)/8.
  2429 F2AB 23            		INX	H	;at lease 1 byte.
  2430 F2AC 44            		MOV	B,H
  2431 F2AD 4D            		MOV	C,L	;set (BC) to the allocation table length.
  2432                    	;
  2433                    	;   Initialize the bitmap for this drive. Right now, the first
  2434                    	; two bytes are specified by the disk parameter block. However
  2435                    	; a patch could be entered here if it were necessary to setup
  2436                    	; this table in a special mannor. For example, the bios could
  2437                    	; determine locations of 'bad blocks' and set them as already
  2438                    	; 'used' in the map.
  2439                    	;
  2440 F2AE 2A BF F9      		LHLD	ALOCVECT;now zero out the table now.
  2441 F2B1 36 00         	BITMAP1	MVI	M,0
  2442 F2B3 23            		INX	H
  2443 F2B4 0B            		DCX	B
  2444 F2B5 78            		MOV	A,B
  2445 F2B6 B1            		ORA	C
  2446 F2B7 C2 B1 F2      		JNZ	BITMAP1
  2447 F2BA 2A CA F9      		LHLD	ALLOC0	;get initial space used by directory.
  2448 F2BD EB            		XCHG
  2449 F2BE 2A BF F9      		LHLD	ALOCVECT;and put this into map.
  2450 F2C1 73            		MOV	M,E
  2451 F2C2 23            		INX	H
  2452 F2C3 72            		MOV	M,D
  2453                    	;
  2454                    	;   End of initialization portion.
  2455                    	;
  2456 F2C4 CD A1 EF      		CALL	HOMEDRV	;now home the drive.
  2457 F2C7 2A B3 F9      		LHLD	SCRATCH1
  2458 F2CA 36 03         		MVI	M,3	;force next directory request to read
  2459 F2CC 23            		INX	H	;in a sector.
  2460 F2CD 36 00         		MVI	M,0
  2461 F2CF CD FE F1      		CALL	STFILPOS;clear initial file position also.
  2462 F2D2 0E FF         	BITMAP2	MVI	C,0FFH	;read next file name in directory
  2463 F2D4 CD 05 F2      		CALL	NXENTRY	;and set checksum byte.
  2464 F2D7 CD F5 F1      		CALL	CKFILPOS;is there another file?
  2465 F2DA C8            		RZ
  2466 F2DB CD 5E F1      		CALL	FCB2HL	;yes, get its address.
  2467 F2DE 3E E5         		MVI	A,0E5H
  2468 F2E0 BE            		CMP	M	;empty file entry?
  2469 F2E1 CA D2 F2      		JZ	BITMAP2
  2470 F2E4 3A 41 EF      		LDA	USERNO	;no, correct user number?
  2471 F2E7 BE            		CMP	M
  2472 F2E8 C2 F6 F2      		JNZ	BITMAP3
  2473 F2EB 23            		INX	H
  2474 F2EC 7E            		MOV	A,M	;yes, does name start with a '$'?
  2475 F2ED D6 24         		SUI	'$'
  2476 F2EF C2 F6 F2      		JNZ	BITMAP3
  2477 F2F2 3D            		DCR	A	;yes, set atatus to minus one.
  2478 F2F3 32 45 EF      		STA	STATUS
  2479 F2F6 0E 01         	BITMAP3	MVI	C,1	;now set this file's space as used in bit map.
  2480 F2F8 CD 6B F2      		CALL	SETFILE
  2481 F2FB CD 8C F1      		CALL	CHKNMBR	;keep (SCRATCH1) in bounds.
  2482 F2FE C3 D2 F2      		JMP	BITMAP2
  2483                    	;
  2484                    	;   Set the status (STATUS) and return.
  2485                    	;
  2486 F301 3A D4 F9      	STSTATUS:LDA	FNDSTAT
  2487 F304 C3 01 EF      		JMP	SETSTAT
  2488                    	;
  2489                    	;   Check extents in (A) and (C). Set the zero flag if they
  2490                    	; are the same. The number of 16k chunks of disk space that
  2491                    	; the directory extent covers is expressad is (EXTMASK+1).
  2492                    	; No registers are modified.
  2493                    	;
  2494 F307 C5            	SAMEXT	PUSH	B
  2495 F308 F5            		PUSH	PSW
  2496 F309 3A C5 F9      		LDA	EXTMASK	;get extent mask and use it to
  2497 F30C 2F            		CMA		;to compare both extent numbers.
  2498 F30D 47            		MOV	B,A	;save resulting mask here.
  2499 F30E 79            		MOV	A,C	;mask first extent and save in (C).
  2500 F30F A0            		ANA	B
  2501 F310 4F            		MOV	C,A
  2502 F311 F1            		POP	PSW	;now mask second extent and compare
  2503 F312 A0            		ANA	B	;with the first one.
  2504 F313 91            		SUB	C
  2505 F314 E6 1F         		ANI	1FH	;(* only check buts 0-4 *)
  2506 F316 C1            		POP	B	;the zero flag is set if they are the same.
  2507 F317 C9            		RET		;restore (BC) and return.
  2508                    	;
  2509                    	;   Search for the first occurence of a file name. On entry,
  2510                    	; register (C) should contain the number of bytes of the fcb
  2511                    	; that must match.
  2512                    	;
  2513 F318 3E FF         	FINDFST	MVI	A,0FFH
  2514 F31A 32 D4 F9      		STA	FNDSTAT
  2515 F31D 21 D8 F9      		LXI	H,COUNTER;save character count.
  2516 F320 71            		MOV	M,C
  2517 F321 2A 43 EF      		LHLD	PARAMS	;get filename to match.
  2518 F324 22 D9 F9      		SHLD	SAVEFCB	;and save.
  2519 F327 CD FE F1      		CALL	STFILPOS;clear initial file position (set to 0ffffh).
  2520 F32A CD A1 EF      		CALL	HOMEDRV	;home the drive.
  2521                    	;
  2522                    	;   Entry to locate the next occurence of a filename within the
  2523                    	; directory. The disk is not expected to have been changed. If
  2524                    	; it was, then it will be write protected.
  2525                    	;
  2526 F32D 0E 00         	FINDNXT	MVI	C,0	;write protect the disk if changed.
  2527 F32F CD 05 F2      		CALL	NXENTRY	;get next filename entry in directory.
  2528 F332 CD F5 F1      		CALL	CKFILPOS;is file position = 0ffffh?
  2529 F335 CA 94 F3      		JZ	FNDNXT6	;yes, exit now then.
  2530 F338 2A D9 F9      		LHLD	SAVEFCB	;set (DE) pointing to filename to match.
  2531 F33B EB            		XCHG
  2532 F33C 1A            		LDAX	D
  2533 F33D FE E5         		CPI	0E5H	;empty directory entry?
  2534 F33F CA 4A F3      		JZ	FNDNXT1	;(* are we trying to reserect erased entries? *)
  2535 F342 D5            		PUSH	D
  2536 F343 CD 7F F1      		CALL	MOREFLS	;more files in directory?
  2537 F346 D1            		POP	D
  2538 F347 D2 94 F3      		JNC	FNDNXT6	;no more. Exit now.
  2539 F34A CD 5E F1      	FNDNXT1	CALL	FCB2HL	;get address of this fcb in directory.
  2540 F34D 3A D8 F9      		LDA	COUNTER	;get number of bytes (characters) to check.
  2541 F350 4F            		MOV	C,A
  2542 F351 06 00         		MVI	B,0	;initialize byte position counter.
  2543 F353 79            	FNDNXT2	MOV	A,C	;are we done with the compare?
  2544 F354 B7            		ORA	A
  2545 F355 CA 83 F3      		JZ	FNDNXT5
  2546 F358 1A            		LDAX	D	;no, check next byte.
  2547 F359 FE 3F         		CPI	'?'	;don't care about this character?
  2548 F35B CA 7C F3      		JZ	FNDNXT4
  2549 F35E 78            		MOV	A,B	;get bytes position in fcb.
  2550 F35F FE 0D         		CPI	13	;don't care about the thirteenth byte either.
  2551 F361 CA 7C F3      		JZ	FNDNXT4
  2552 F364 FE 0C         		CPI	12	;extent byte?
  2553 F366 1A            		LDAX	D
  2554 F367 CA 73 F3      		JZ	FNDNXT3
  2555 F36A 96            		SUB	M	;otherwise compare characters.
  2556 F36B E6 7F         		ANI	7FH
  2557 F36D C2 2D F3      		JNZ	FINDNXT	;not the same, check next entry.
  2558 F370 C3 7C F3      		JMP	FNDNXT4	;so far so good, keep checking.
  2559 F373 C5            	FNDNXT3	PUSH	B	;check the extent byte here.
  2560 F374 4E            		MOV	C,M
  2561 F375 CD 07 F3      		CALL	SAMEXT
  2562 F378 C1            		POP	B
  2563 F379 C2 2D F3      		JNZ	FINDNXT	;not the same, look some more.
  2564                    	;
  2565                    	;   So far the names compare. Bump pointers to the next byte
  2566                    	; and continue until all (C) characters have been checked.
  2567                    	;
  2568 F37C 13            	FNDNXT4	INX	D	;bump pointers.
  2569 F37D 23            		INX	H
  2570 F37E 04            		INR	B
  2571 F37F 0D            		DCR	C	;adjust character counter.
  2572 F380 C3 53 F3      		JMP	FNDNXT2
  2573 F383 3A EA F9      	FNDNXT5	LDA	FILEPOS	;return the position of this entry.
  2574 F386 E6 03         		ANI	03H
  2575 F388 32 45 EF      		STA	STATUS
  2576 F38B 21 D4 F9      		LXI	H,FNDSTAT
  2577 F38E 7E            		MOV	A,M
  2578 F38F 17            		RAL
  2579 F390 D0            		RNC
  2580 F391 AF            		XRA	A
  2581 F392 77            		MOV	M,A
  2582 F393 C9            		RET
  2583                    	;
  2584                    	;   Filename was not found. Set appropriate status.
  2585                    	;
  2586 F394 CD FE F1      	FNDNXT6	CALL	STFILPOS;set (FILEPOS) to 0ffffh.
  2587 F397 3E FF         		MVI	A,0FFH	;say not located.
  2588 F399 C3 01 EF      		JMP	SETSTAT
  2589                    	;
  2590                    	;   Erase files from the directory. Only the first byte of the
  2591                    	; fcb will be affected. It is set to (E5).
  2592                    	;
  2593 F39C CD 54 F1      	ERAFILE	CALL	CHKWPRT	;is disk write protected?
  2594 F39F 0E 0C         		MVI	C,12	;only compare file names.
  2595 F3A1 CD 18 F3      		CALL	FINDFST	;get first file name.
  2596 F3A4 CD F5 F1      	ERAFIL1	CALL	CKFILPOS;any found?
  2597 F3A7 C8            		RZ		;nope, we must be done.
  2598 F3A8 CD 44 F1      		CALL	CHKROFL	;is file read only?
  2599 F3AB CD 5E F1      		CALL	FCB2HL	;nope, get address of fcb and
  2600 F3AE 36 E5         		MVI	M,0E5H	;set first byte to 'empty'.
  2601 F3B0 0E 00         		MVI	C,0	;clear the space from the bit map.
  2602 F3B2 CD 6B F2      		CALL	SETFILE
  2603 F3B5 CD C6 F1      		CALL	DIRWRITE;now write the directory sector back out.
  2604 F3B8 CD 2D F3      		CALL	FINDNXT	;find the next file name.
  2605 F3BB C3 A4 F3      		JMP	ERAFIL1	;and repeat process.
  2606                    	;
  2607                    	;   Look through the space allocation map (bit map) for the
  2608                    	; next available block. Start searching at block number (BC-1).
  2609                    	; The search procedure is to look for an empty block that is
  2610                    	; before the starting block. If not empty, look at a later
  2611                    	; block number. In this way, we return the closest empty block
  2612                    	; on either side of the 'target' block number. This will speed
  2613                    	; access on random devices. For serial devices, this should be
  2614                    	; changed to look in the forward direction first and then start
  2615                    	; at the front and search some more.
  2616                    	;
  2617                    	;   On return, (DE)= block number that is empty and (HL) =0
  2618                    	; if no empry block was found.
  2619                    	;
  2620 F3BE 50            	FNDSPACE:MOV	D,B	;set (DE) as the block that is checked.
  2621 F3BF 59            		MOV	E,C
  2622                    	;
  2623                    	;   Look before target block. Registers (BC) are used as the lower
  2624                    	; pointer and (DE) as the upper pointer.
  2625                    	;
  2626 F3C0 79            	FNDSPA1	MOV	A,C	;is block 0 specified?
  2627 F3C1 B0            		ORA	B
  2628 F3C2 CA D1 F3      		JZ	FNDSPA2
  2629 F3C5 0B            		DCX	B	;nope, check previous block.
  2630 F3C6 D5            		PUSH	D
  2631 F3C7 C5            		PUSH	B
  2632 F3C8 CD 35 F2      		CALL	CKBITMAP
  2633 F3CB 1F            		RAR		;is this block empty?
  2634 F3CC D2 EC F3      		JNC	FNDSPA3	;yes. use this.
  2635                    	;
  2636                    	;   Note that the above logic gets the first block that it finds
  2637                    	; that is empty. Thus a file could be written 'backward' making
  2638                    	; it very slow to access. This could be changed to look for the
  2639                    	; first empty block and then continue until the start of this
  2640                    	; empty space is located and then used that starting block.
  2641                    	; This should help speed up access to some files especially on
  2642                    	; a well used disk with lots of fairly small 'holes'.
  2643                    	;
  2644 F3CF C1            		POP	B	;nope, check some more.
  2645 F3D0 D1            		POP	D
  2646                    	;
  2647                    	;   Now look after target block.
  2648                    	;
  2649 F3D1 2A C6 F9      	FNDSPA2	LHLD	DSKSIZE	;is block (DE) within disk limits?
  2650 F3D4 7B            		MOV	A,E
  2651 F3D5 95            		SUB	L
  2652 F3D6 7A            		MOV	A,D
  2653 F3D7 9C            		SBB	H
  2654 F3D8 D2 F4 F3      		JNC	FNDSPA4
  2655 F3DB 13            		INX	D	;yes, move on to next one.
  2656 F3DC C5            		PUSH	B
  2657 F3DD D5            		PUSH	D
  2658 F3DE 42            		MOV	B,D
  2659 F3DF 4B            		MOV	C,E
  2660 F3E0 CD 35 F2      		CALL	CKBITMAP;check it.
  2661 F3E3 1F            		RAR		;empty?
  2662 F3E4 D2 EC F3      		JNC	FNDSPA3
  2663 F3E7 D1            		POP	D	;nope, continue searching.
  2664 F3E8 C1            		POP	B
  2665 F3E9 C3 C0 F3      		JMP	FNDSPA1
  2666                    	;
  2667                    	;   Empty block found. Set it as used and return with (HL)
  2668                    	; pointing to it (true?).
  2669                    	;
  2670 F3EC 17            	FNDSPA3	RAL		;reset byte.
  2671 F3ED 3C            		INR	A	;and set bit 0.
  2672 F3EE CD 64 F2      		CALL	STBMAP1	;update bit map.
  2673 F3F1 E1            		POP	H	;set return registers.
  2674 F3F2 D1            		POP	D
  2675 F3F3 C9            		RET
  2676                    	;
  2677                    	;   Free block was not found. If (BC) is not zero, then we have
  2678                    	; not checked all of the disk space.
  2679                    	;
  2680 F3F4 79            	FNDSPA4	MOV	A,C
  2681 F3F5 B0            		ORA	B
  2682 F3F6 C2 C0 F3      		JNZ	FNDSPA1
  2683 F3F9 21 00 00      		LXI	H,0	;set 'not found' status.
  2684 F3FC C9            		RET
  2685                    	;
  2686                    	;   Move a complete fcb entry into the directory and write it.
  2687                    	;
  2688 F3FD 0E 00         	FCBSET	MVI	C,0
  2689 F3FF 1E 20         		MVI	E,32	;length of each entry.
  2690                    	;
  2691                    	;   Move (E) bytes from the fcb pointed to by (PARAMS) into
  2692                    	; fcb in directory starting at relative byte (C). This updated
  2693                    	; directory buffer is then written to the disk.
  2694                    	;
  2695 F401 D5            	UPDATE	PUSH	D
  2696 F402 06 00         		MVI	B,0	;set (BC) to relative byte position.
  2697 F404 2A 43 EF      		LHLD	PARAMS	;get address of fcb.
  2698 F407 09            		DAD	B	;compute starting byte.
  2699 F408 EB            		XCHG
  2700 F409 CD 5E F1      		CALL	FCB2HL	;get address of fcb to update in directory.
  2701 F40C C1            		POP	B	;set (C) to number of bytes to change.
  2702 F40D CD 4F EF      		CALL	DE2HL
  2703 F410 CD C3 EF      	UPDATE1	CALL	TRKSEC	;determine the track and sector affected.
  2704 F413 C3 C6 F1      		JMP	DIRWRITE	;then write this sector out.
  2705                    	;
  2706                    	;   Routine to change the name of all files on the disk with a
  2707                    	; specified name. The fcb contains the current name as the
  2708                    	; first 12 characters and the new name 16 bytes into the fcb.
  2709                    	;
  2710 F416 CD 54 F1      	CHGNAMES:CALL	CHKWPRT	;check for a write protected disk.
  2711 F419 0E 0C         		MVI	C,12	;match first 12 bytes of fcb only.
  2712 F41B CD 18 F3      		CALL	FINDFST	;get first name.
  2713 F41E 2A 43 EF      		LHLD	PARAMS	;get address of fcb.
  2714 F421 7E            		MOV	A,M	;get user number.
  2715 F422 11 10 00      		LXI	D,16	;move over to desired name.
  2716 F425 19            		DAD	D
  2717 F426 77            		MOV	M,A	;keep same user number.
  2718 F427 CD F5 F1      	CHGNAM1	CALL	CKFILPOS;any matching file found?
  2719 F42A C8            		RZ		;no, we must be done.
  2720 F42B CD 44 F1      		CALL	CHKROFL	;check for read only file.
  2721 F42E 0E 10         		MVI	C,16	;start 16 bytes into fcb.
  2722 F430 1E 0C         		MVI	E,12	;and update the first 12 bytes of directory.
  2723 F432 CD 01 F4      		CALL	UPDATE
  2724 F435 CD 2D F3      		CALL	FINDNXT	;get te next file name.
  2725 F438 C3 27 F4      		JMP	CHGNAM1	;and continue.
  2726                    	;
  2727                    	;   Update a files attributes. The procedure is to search for
  2728                    	; every file with the same name as shown in fcb (ignoring bit 7)
  2729                    	; and then to update it (which includes bit 7). No other changes
  2730                    	; are made.
  2731                    	;
  2732 F43B 0E 0C         	SAVEATTR:MVI	C,12	;match first 12 bytes.
  2733 F43D CD 18 F3      		CALL	FINDFST	;look for first filename.
  2734 F440 CD F5 F1      	SAVATR1	CALL	CKFILPOS;was one found?
  2735 F443 C8            		RZ		;nope, we must be done.
  2736 F444 0E 00         		MVI	C,0	;yes, update the first 12 bytes now.
  2737 F446 1E 0C         		MVI	E,12
  2738 F448 CD 01 F4      		CALL	UPDATE	;update filename and write directory.
  2739 F44B CD 2D F3      		CALL	FINDNXT	;and get the next file.
  2740 F44E C3 40 F4      		JMP	SAVATR1	;then continue until done.
  2741                    	;
  2742                    	;  Open a file (name specified in fcb).
  2743                    	;
  2744 F451 0E 0F         	OPENIT	MVI	C,15	;compare the first 15 bytes.
  2745 F453 CD 18 F3      		CALL	FINDFST	;get the first one in directory.
  2746 F456 CD F5 F1      		CALL	CKFILPOS;any at all?
  2747 F459 C8            		RZ
  2748 F45A CD A6 F0      	OPENIT1	CALL	SETEXT	;point to extent byte within users fcb.
  2749 F45D 7E            		MOV	A,M	;and get it.
  2750 F45E F5            		PUSH	PSW	;save it and address.
  2751 F45F E5            		PUSH	H
  2752 F460 CD 5E F1      		CALL	FCB2HL	;point to fcb in directory.
  2753 F463 EB            		XCHG
  2754 F464 2A 43 EF      		LHLD	PARAMS	;this is the users copy.
  2755 F467 0E 20         		MVI	C,32	;move it into users space.
  2756 F469 D5            		PUSH	D
  2757 F46A CD 4F EF      		CALL	DE2HL
  2758 F46D CD 78 F1      		CALL	SETS2B7	;set bit 7 in 's2' byte (unmodified).
  2759 F470 D1            		POP	D	;now get the extent byte from this fcb.
  2760 F471 21 0C 00      		LXI	H,12
  2761 F474 19            		DAD	D
  2762 F475 4E            		MOV	C,M	;into (C).
  2763 F476 21 0F 00      		LXI	H,15	;now get the record count byte into (B).
  2764 F479 19            		DAD	D
  2765 F47A 46            		MOV	B,M
  2766 F47B E1            		POP	H	;keep the same extent as the user had originally.
  2767 F47C F1            		POP	PSW
  2768 F47D 77            		MOV	M,A
  2769 F47E 79            		MOV	A,C	;is it the same as in the directory fcb?
  2770 F47F BE            		CMP	M
  2771 F480 78            		MOV	A,B	;if yes, then use the same record count.
  2772 F481 CA 8B F4      		JZ	OPENIT2
  2773 F484 3E 00         		MVI	A,0	;if the user specified an extent greater than
  2774 F486 DA 8B F4      		JC	OPENIT2	;the one in the directory, then set record count to 0.
  2775 F489 3E 80         		MVI	A,128	;otherwise set to maximum.
  2776 F48B 2A 43 EF      	OPENIT2	LHLD	PARAMS	;set record count in users fcb to (A).
  2777 F48E 11 0F 00      		LXI	D,15
  2778 F491 19            		DAD	D	;compute relative position.
  2779 F492 77            		MOV	M,A	;and set the record count.
  2780 F493 C9            		RET
  2781                    	;
  2782                    	;   Move two bytes from (DE) to (HL) if (and only if) (HL)
  2783                    	; point to a zero value (16 bit).
  2784                    	;   Return with zero flag set it (DE) was moved. Registers (DE)
  2785                    	; and (HL) are not changed. However (A) is.
  2786                    	;
  2787 F494 7E            	MOVEWORD:MOV	A,M	;check for a zero word.
  2788 F495 23            		INX	H
  2789 F496 B6            		ORA	M	;both bytes zero?
  2790 F497 2B            		DCX	H
  2791 F498 C0            		RNZ		;nope, just return.
  2792 F499 1A            		LDAX	D	;yes, move two bytes from (DE) into
  2793 F49A 77            		MOV	M,A	;this zero space.
  2794 F49B 13            		INX	D
  2795 F49C 23            		INX	H
  2796 F49D 1A            		LDAX	D
  2797 F49E 77            		MOV	M,A
  2798 F49F 1B            		DCX	D	;don't disturb these registers.
  2799 F4A0 2B            		DCX	H
  2800 F4A1 C9            		RET
  2801                    	;
  2802                    	;   Get here to close a file specified by (fcb).
  2803                    	;
  2804 F4A2 AF            	CLOSEIT	XRA	A	;clear status and file position bytes.
  2805 F4A3 32 45 EF      		STA	STATUS
  2806 F4A6 32 EA F9      		STA	FILEPOS
  2807 F4A9 32 EB F9      		STA	FILEPOS+1
  2808 F4AC CD 1E F1      		CALL	GETWPRT	;get write protect bit for this drive.
  2809 F4AF C0            		RNZ		;just return if it is set.
  2810 F4B0 CD 69 F1      		CALL	GETS2	;else get the 's2' byte.
  2811 F4B3 E6 80         		ANI	80H	;and look at bit 7 (file unmodified?).
  2812 F4B5 C0            		RNZ		;just return if set.
  2813 F4B6 0E 0F         		MVI	C,15	;else look up this file in directory.
  2814 F4B8 CD 18 F3      		CALL	FINDFST
  2815 F4BB CD F5 F1      		CALL	CKFILPOS;was it found?
  2816 F4BE C8            		RZ		;just return if not.
  2817 F4BF 01 10 00      		LXI	B,16	;set (HL) pointing to records used section.
  2818 F4C2 CD 5E F1      		CALL	FCB2HL
  2819 F4C5 09            		DAD	B
  2820 F4C6 EB            		XCHG
  2821 F4C7 2A 43 EF      		LHLD	PARAMS	;do the same for users specified fcb.
  2822 F4CA 09            		DAD	B
  2823 F4CB 0E 10         		MVI	C,16	;this many bytes are present in this extent.
  2824 F4CD 3A DD F9      	CLOSEIT1:LDA	BIGDISK	;8 or 16 bit record numbers?
  2825 F4D0 B7            		ORA	A
  2826 F4D1 CA E8 F4      		JZ	CLOSEIT4
  2827 F4D4 7E            		MOV	A,M	;just 8 bit. Get one from users fcb.
  2828 F4D5 B7            		ORA	A
  2829 F4D6 1A            		LDAX	D	;now get one from directory fcb.
  2830 F4D7 C2 DB F4      		JNZ	CLOSEIT2
  2831 F4DA 77            		MOV	M,A	;users byte was zero. Update from directory.
  2832 F4DB B7            	CLOSEIT2:ORA	A
  2833 F4DC C2 E1 F4      		JNZ	CLOSEIT3
  2834 F4DF 7E            		MOV	A,M	;directories byte was zero, update from users fcb.
  2835 F4E0 12            		STAX	D
  2836 F4E1 BE            	CLOSEIT3:CMP	M	;if neither one of these bytes were zero,
  2837 F4E2 C2 1F F5      		JNZ	CLOSEIT7	;then close error if they are not the same.
  2838 F4E5 C3 FD F4      		JMP	CLOSEIT5	;ok so far, get to next byte in fcbs.
  2839 F4E8 CD 94 F4      	CLOSEIT4:CALL	MOVEWORD;update users fcb if it is zero.
  2840 F4EB EB            		XCHG
  2841 F4EC CD 94 F4      		CALL	MOVEWORD;update directories fcb if it is zero.
  2842 F4EF EB            		XCHG
  2843 F4F0 1A            		LDAX	D	;if these two values are no different,
  2844 F4F1 BE            		CMP	M	;then a close error occured.
  2845 F4F2 C2 1F F5      		JNZ	CLOSEIT7
  2846 F4F5 13            		INX	D	;check second byte.
  2847 F4F6 23            		INX	H
  2848 F4F7 1A            		LDAX	D
  2849 F4F8 BE            		CMP	M
  2850 F4F9 C2 1F F5      		JNZ	CLOSEIT7
  2851 F4FC 0D            		DCR	C	;remember 16 bit values.
  2852 F4FD 13            	CLOSEIT5:INX	D	;bump to next item in table.
  2853 F4FE 23            		INX	H
  2854 F4FF 0D            		DCR	C	;there are 16 entries only.
  2855 F500 C2 CD F4      		JNZ	CLOSEIT1;continue if more to do.
  2856 F503 01 EC FF      		LXI	B,0FFECH;backup 20 places (extent byte).
  2857 F506 09            		DAD	B
  2858 F507 EB            		XCHG
  2859 F508 09            		DAD	B
  2860 F509 1A            		LDAX	D
  2861 F50A BE            		CMP	M	;directory's extent already greater than the
  2862 F50B DA 17 F5      		JC	CLOSEIT6	;users extent?
  2863 F50E 77            		MOV	M,A	;no, update directory extent.
  2864 F50F 01 03 00      		LXI	B,3	;and update the record count byte in
  2865 F512 09            		DAD	B	;directories fcb.
  2866 F513 EB            		XCHG
  2867 F514 09            		DAD	B
  2868 F515 7E            		MOV	A,M	;get from user.
  2869 F516 12            		STAX	D	;and put in directory.
  2870 F517 3E FF         	CLOSEIT6:MVI	A,0FFH	;set 'was open and is now closed' byte.
  2871 F519 32 D2 F9      		STA	CLOSEFLG
  2872 F51C C3 10 F4      		JMP	UPDATE1	;update the directory now.
  2873 F51F 21 45 EF      	CLOSEIT7:LXI	H,STATUS;set return status and then return.
  2874 F522 35            		DCR	M
  2875 F523 C9            		RET
  2876                    	;
  2877                    	;   Routine to get the next empty space in the directory. It
  2878                    	; will then be cleared for use.
  2879                    	;
  2880 F524 CD 54 F1      	GETEMPTY:CALL	CHKWPRT	;make sure disk is not write protected.
  2881 F527 2A 43 EF      		LHLD	PARAMS	;save current parameters (fcb).
  2882 F52A E5            		PUSH	H
  2883 F52B 21 AC F9      		LXI	H,EMPTYFCB;use special one for empty space.
  2884 F52E 22 43 EF      		SHLD	PARAMS
  2885 F531 0E 01         		MVI	C,1	;search for first empty spot in directory.
  2886 F533 CD 18 F3      		CALL	FINDFST	;(* only check first byte *)
  2887 F536 CD F5 F1      		CALL	CKFILPOS;none?
  2888 F539 E1            		POP	H
  2889 F53A 22 43 EF      		SHLD	PARAMS	;restore original fcb address.
  2890 F53D C8            		RZ		;return if no more space.
  2891 F53E EB            		XCHG
  2892 F53F 21 0F 00      		LXI	H,15	;point to number of records for this file.
  2893 F542 19            		DAD	D
  2894 F543 0E 11         		MVI	C,17	;and clear all of this space.
  2895 F545 AF            		XRA	A
  2896 F546 77            	GETMT1	MOV	M,A
  2897 F547 23            		INX	H
  2898 F548 0D            		DCR	C
  2899 F549 C2 46 F5      		JNZ	GETMT1
  2900 F54C 21 0D 00      		LXI	H,13	;clear the 's1' byte also.
  2901 F54F 19            		DAD	D
  2902 F550 77            		MOV	M,A
  2903 F551 CD 8C F1      		CALL	CHKNMBR	;keep (SCRATCH1) within bounds.
  2904 F554 CD FD F3      		CALL	FCBSET	;write out this fcb entry to directory.
  2905 F557 C3 78 F1      		JMP	SETS2B7	;set 's2' byte bit 7 (unmodified at present).
  2906                    	;
  2907                    	;   Routine to close the current extent and open the next one
  2908                    	; for reading.
  2909                    	;
  2910 F55A AF            	GETNEXT	XRA	A
  2911 F55B 32 D2 F9      		STA	CLOSEFLG;clear close flag.
  2912 F55E CD A2 F4      		CALL	CLOSEIT	;close this extent.
  2913 F561 CD F5 F1      		CALL	CKFILPOS
  2914 F564 C8            		RZ		;not there???
  2915 F565 2A 43 EF      		LHLD	PARAMS	;get extent byte.
  2916 F568 01 0C 00      		LXI	B,12
  2917 F56B 09            		DAD	B
  2918 F56C 7E            		MOV	A,M	;and increment it.
  2919 F56D 3C            		INR	A
  2920 F56E E6 1F         		ANI	1FH	;keep within range 0-31.
  2921 F570 77            		MOV	M,A
  2922 F571 CA 83 F5      		JZ	GTNEXT1	;overflow?
  2923 F574 47            		MOV	B,A	;mask extent byte.
  2924 F575 3A C5 F9      		LDA	EXTMASK
  2925 F578 A0            		ANA	B
  2926 F579 21 D2 F9      		LXI	H,CLOSEFLG;check close flag (0ffh is ok).
  2927 F57C A6            		ANA	M
  2928 F57D CA 8E F5      		JZ	GTNEXT2	;if zero, we must read in next extent.
  2929 F580 C3 AC F5      		JMP	GTNEXT3	;else, it is already in memory.
  2930 F583 01 02 00      	GTNEXT1	LXI	B,2	;Point to the 's2' byte.
  2931 F586 09            		DAD	B
  2932 F587 34            		INR	M	;and bump it.
  2933 F588 7E            		MOV	A,M	;too many extents?
  2934 F589 E6 0F         		ANI	0FH
  2935 F58B CA B6 F5      		JZ	GTNEXT5	;yes, set error code.
  2936                    	;
  2937                    	;   Get here to open the next extent.
  2938                    	;
  2939 F58E 0E 0F         	GTNEXT2	MVI	C,15	;set to check first 15 bytes of fcb.
  2940 F590 CD 18 F3      		CALL	FINDFST	;find the first one.
  2941 F593 CD F5 F1      		CALL	CKFILPOS;none available?
  2942 F596 C2 AC F5      		JNZ	GTNEXT3
  2943 F599 3A D3 F9      		LDA	RDWRTFLG;no extent present. Can we open an empty one?
  2944 F59C 3C            		INR	A	;0ffh means reading (so not possible).
  2945 F59D CA B6 F5      		JZ	GTNEXT5	;or an error.
  2946 F5A0 CD 24 F5      		CALL	GETEMPTY;we are writing, get an empty entry.
  2947 F5A3 CD F5 F1      		CALL	CKFILPOS;none?
  2948 F5A6 CA B6 F5      		JZ	GTNEXT5	;error if true.
  2949 F5A9 C3 AF F5      		JMP	GTNEXT4	;else we are almost done.
  2950 F5AC CD 5A F4      	GTNEXT3	CALL	OPENIT1	;open this extent.
  2951 F5AF CD BB F0      	GTNEXT4	CALL	STRDATA	;move in updated data (rec #, extent #, etc.)
  2952 F5B2 AF            		XRA	A	;clear status and return.
  2953 F5B3 C3 01 EF      		JMP	SETSTAT
  2954                    	;
  2955                    	;   Error in extending the file. Too many extents were needed
  2956                    	; or not enough space on the disk.
  2957                    	;
  2958 F5B6 CD 05 EF      	GTNEXT5	CALL	IOERR1	;set error code, clear bit 7 of 's2'
  2959 F5B9 C3 78 F1      		JMP	SETS2B7	;so this is not written on a close.
  2960                    	;
  2961                    	;   Read a sequential file.
  2962                    	;
  2963 F5BC 3E 01         	RDSEQ	MVI	A,1	;set sequential access mode.
  2964 F5BE 32 D5 F9      		STA	MODE
  2965 F5C1 3E FF         	RDSEQ1	MVI	A,0FFH	;don't allow reading unwritten space.
  2966 F5C3 32 D3 F9      		STA	RDWRTFLG
  2967 F5C6 CD BB F0      		CALL	STRDATA	;put rec# and ext# into fcb.
  2968 F5C9 3A E3 F9      		LDA	SAVNREC	;get next record to read.
  2969 F5CC 21 E1 F9      		LXI	H,SAVNXT;get number of records in extent.
  2970 F5CF BE            		CMP	M	;within this extent?
  2971 F5D0 DA E6 F5      		JC	RDSEQ2
  2972 F5D3 FE 80         		CPI	128	;no. Is this extent fully used?
  2973 F5D5 C2 FB F5      		JNZ	RDSEQ3	;no. End-of-file.
  2974 F5D8 CD 5A F5      		CALL	GETNEXT	;yes, open the next one.
  2975 F5DB AF            		XRA	A	;reset next record to read.
  2976 F5DC 32 E3 F9      		STA	SAVNREC
  2977 F5DF 3A 45 EF      		LDA	STATUS	;check on open, successful?
  2978 F5E2 B7            		ORA	A
  2979 F5E3 C2 FB F5      		JNZ	RDSEQ3	;no, error.
  2980 F5E6 CD 77 F0      	RDSEQ2	CALL	COMBLK	;ok. compute block number to read.
  2981 F5E9 CD 84 F0      		CALL	CHKBLK	;check it. Within bounds?
  2982 F5EC CA FB F5      		JZ	RDSEQ3	;no, error.
  2983 F5EF CD 8A F0      		CALL	LOGICAL	;convert (BLKNMBR) to logical sector (128 byte).
  2984 F5F2 CD D1 EF      		CALL	TRKSEC1	;set the track and sector for this block #.
  2985 F5F5 CD B2 EF      		CALL	DOREAD	;and read it.
  2986 F5F8 C3 D2 F0      		JMP	SETNREC	;and set the next record to be accessed.
  2987                    	;
  2988                    	;   Read error occured. Set status and return.
  2989                    	;
  2990 F5FB C3 05 EF      	RDSEQ3	JMP	IOERR1
  2991                    	;
  2992                    	;   Write the next sequential record.
  2993                    	;
  2994 F5FE 3E 01         	WTSEQ	MVI	A,1	;set sequential access mode.
  2995 F600 32 D5 F9      		STA	MODE
  2996 F603 3E 00         	WTSEQ1	MVI	A,0	;allow an addition empty extent to be opened.
  2997 F605 32 D3 F9      		STA	RDWRTFLG
  2998 F608 CD 54 F1      		CALL	CHKWPRT	;check write protect status.
  2999 F60B 2A 43 EF      		LHLD	PARAMS
  3000 F60E CD 47 F1      		CALL	CKROF1	;check for read only file, (HL) already set to fcb.
  3001 F611 CD BB F0      		CALL	STRDATA	;put updated data into fcb.
  3002 F614 3A E3 F9      		LDA	SAVNREC	;get record number to write.
  3003 F617 FE 80         		CPI	128	;within range?
  3004 F619 D2 05 EF      		JNC	IOERR1	;no, error(?).
  3005 F61C CD 77 F0      		CALL	COMBLK	;compute block number.
  3006 F61F CD 84 F0      		CALL	CHKBLK	;check number.
  3007 F622 0E 00         		MVI	C,0	;is there one to write to?
  3008 F624 C2 6E F6      		JNZ	WTSEQ6	;yes, go do it.
  3009 F627 CD 3E F0      		CALL	GETBLOCK;get next block number within fcb to use.
  3010 F62A 32 D7 F9      		STA	RELBLOCK;and save.
  3011 F62D 01 00 00      		LXI	B,0	;start looking for space from the start
  3012 F630 B7            		ORA	A	;if none allocated as yet.
  3013 F631 CA 3B F6      		JZ	WTSEQ2
  3014 F634 4F            		MOV	C,A	;extract previous block number from fcb
  3015 F635 0B            		DCX	B	;so we can be closest to it.
  3016 F636 CD 5E F0      		CALL	EXTBLK
  3017 F639 44            		MOV	B,H
  3018 F63A 4D            		MOV	C,L
  3019 F63B CD BE F3      	WTSEQ2	CALL	FNDSPACE;find the next empty block nearest number (BC).
  3020 F63E 7D            		MOV	A,L	;check for a zero number.
  3021 F63F B4            		ORA	H
  3022 F640 C2 48 F6      		JNZ	WTSEQ3
  3023 F643 3E 02         		MVI	A,2	;no more space?
  3024 F645 C3 01 EF      		JMP	SETSTAT
  3025 F648 22 E5 F9      	WTSEQ3	SHLD	BLKNMBR	;save block number to access.
  3026 F64B EB            		XCHG		;put block number into (DE).
  3027 F64C 2A 43 EF      		LHLD	PARAMS	;now we must update the fcb for this
  3028 F64F 01 10 00      		LXI	B,16	;newly allocated block.
  3029 F652 09            		DAD	B
  3030 F653 3A DD F9      		LDA	BIGDISK	;8 or 16 bit block numbers?
  3031 F656 B7            		ORA	A
  3032 F657 3A D7 F9      		LDA	RELBLOCK	;(* update this entry *)
  3033 F65A CA 64 F6      		JZ	WTSEQ4	;zero means 16 bit ones.
  3034 F65D CD 64 F1      		CALL	ADDA2HL	;(HL)=(HL)+(A)
  3035 F660 73            		MOV	M,E	;store new block number.
  3036 F661 C3 6C F6      		JMP	WTSEQ5
  3037 F664 4F            	WTSEQ4	MOV	C,A	;compute spot in this 16 bit table.
  3038 F665 06 00         		MVI	B,0
  3039 F667 09            		DAD	B
  3040 F668 09            		DAD	B
  3041 F669 73            		MOV	M,E	;stuff block number (DE) there.
  3042 F66A 23            		INX	H
  3043 F66B 72            		MOV	M,D
  3044 F66C 0E 02         	WTSEQ5	MVI	C,2	;set (C) to indicate writing to un-used disk space.
  3045 F66E 3A 45 EF      	WTSEQ6	LDA	STATUS	;are we ok so far?
  3046 F671 B7            		ORA	A
  3047 F672 C0            		RNZ
  3048 F673 C5            		PUSH	B	;yes, save write flag for bios (register C).
  3049 F674 CD 8A F0      		CALL	LOGICAL	;convert (BLKNMBR) over to loical sectors.
  3050 F677 3A D5 F9      		LDA	MODE	;get access mode flag (1=sequential,
  3051 F67A 3D            		DCR	A	;0=random, 2=special?).
  3052 F67B 3D            		DCR	A
  3053 F67C C2 BB F6      		JNZ	WTSEQ9
  3054                    	;
  3055                    	;   Special random i/o from function #40. Maybe for M/PM, but the
  3056                    	; current block, if it has not been written to, will be zeroed
  3057                    	; out and then written (reason?).
  3058                    	;
  3059 F67F C1            		POP	B
  3060 F680 C5            		PUSH	B
  3061 F681 79            		MOV	A,C	;get write status flag (2=writing unused space).
  3062 F682 3D            		DCR	A
  3063 F683 3D            		DCR	A
  3064 F684 C2 BB F6      		JNZ	WTSEQ9
  3065 F687 E5            		PUSH	H
  3066 F688 2A B9 F9      		LHLD	DIRBUF	;zero out the directory buffer.
  3067 F68B 57            		MOV	D,A	;note that (A) is zero here.
  3068 F68C 77            	WTSEQ7	MOV	M,A
  3069 F68D 23            		INX	H
  3070 F68E 14            		INR	D	;do 128 bytes.
  3071 F68F F2 8C F6      		JP	WTSEQ7
  3072 F692 CD E0 F1      		CALL	DIRDMA	;tell the bios the dma address for directory access.
  3073 F695 2A E7 F9      		LHLD	LOGSECT	;get sector that starts current block.
  3074 F698 0E 02         		MVI	C,2	;set 'writing to unused space' flag.
  3075 F69A 22 E5 F9      	WTSEQ8	SHLD	BLKNMBR	;save sector to write.
  3076 F69D C5            		PUSH	B
  3077 F69E CD D1 EF      		CALL	TRKSEC1	;determine its track and sector numbers.
  3078 F6A1 C1            		POP	B
  3079 F6A2 CD B8 EF      		CALL	DOWRITE	;now write out 128 bytes of zeros.
  3080 F6A5 2A E5 F9      		LHLD	BLKNMBR	;get sector number.
  3081 F6A8 0E 00         		MVI	C,0	;set normal write flag.
  3082 F6AA 3A C4 F9      		LDA	BLKMASK	;determine if we have written the entire
  3083 F6AD 47            		MOV	B,A	;physical block.
  3084 F6AE A5            		ANA	L
  3085 F6AF B8            		CMP	B
  3086 F6B0 23            		INX	H	;prepare for the next one.
  3087 F6B1 C2 9A F6      		JNZ	WTSEQ8	;continue until (BLKMASK+1) sectors written.
  3088 F6B4 E1            		POP	H	;reset next sector number.
  3089 F6B5 22 E5 F9      		SHLD	BLKNMBR
  3090 F6B8 CD DA F1      		CALL	DEFDMA	;and reset dma address.
  3091                    	;
  3092                    	;   Normal disk write. Set the desired track and sector then
  3093                    	; do the actual write.
  3094                    	;
  3095 F6BB CD D1 EF      	WTSEQ9	CALL	TRKSEC1	;determine track and sector for this write.
  3096 F6BE C1            		POP	B	;get write status flag.
  3097 F6BF C5            		PUSH	B
  3098 F6C0 CD B8 EF      		CALL	DOWRITE	;and write this out.
  3099 F6C3 C1            		POP	B
  3100 F6C4 3A E3 F9      		LDA	SAVNREC	;get number of records in file.
  3101 F6C7 21 E1 F9      		LXI	H,SAVNXT;get last record written.
  3102 F6CA BE            		CMP	M
  3103 F6CB DA D2 F6      		JC	WTSEQ10
  3104 F6CE 77            		MOV	M,A	;we have to update record count.
  3105 F6CF 34            		INR	M
  3106 F6D0 0E 02         		MVI	C,2
  3107                    	;
  3108                    	;*   This area has been patched to correct disk update problem
  3109                    	;* when using blocking and de-blocking in the BIOS.
  3110                    	;
  3111 F6D2 00            	WTSEQ10	NOP		;was 'dcr c'
  3112 F6D3 00            		NOP		;was 'dcr c'
  3113 F6D4 21 00 00      		LXI	H,0	;was 'jnz wtseq99'
  3114                    	;
  3115                    	; *   End of patch.
  3116                    	;
  3117 F6D7 F5            		PUSH	PSW
  3118 F6D8 CD 69 F1      		CALL	GETS2	;set 'extent written to' flag.
  3119 F6DB E6 7F         		ANI	7FH	;(* clear bit 7 *)
  3120 F6DD 77            		MOV	M,A
  3121 F6DE F1            		POP	PSW	;get record count for this extent.
  3122 F6DF FE 7F         	WTSEQ99	CPI	127	;is it full?
  3123 F6E1 C2 00 F7      		JNZ	WTSEQ12
  3124 F6E4 3A D5 F9      		LDA	MODE	;yes, are we in sequential mode?
  3125 F6E7 FE 01         		CPI	1
  3126 F6E9 C2 00 F7      		JNZ	WTSEQ12
  3127 F6EC CD D2 F0      		CALL	SETNREC	;yes, set next record number.
  3128 F6EF CD 5A F5      		CALL	GETNEXT	;and get next empty space in directory.
  3129 F6F2 21 45 EF      		LXI	H,STATUS;ok?
  3130 F6F5 7E            		MOV	A,M
  3131 F6F6 B7            		ORA	A
  3132 F6F7 C2 FE F6      		JNZ	WTSEQ11
  3133 F6FA 3D            		DCR	A	;yes, set record count to -1.
  3134 F6FB 32 E3 F9      		STA	SAVNREC
  3135 F6FE 36 00         	WTSEQ11	MVI	M,0	;clear status.
  3136 F700 C3 D2 F0      	WTSEQ12	JMP	SETNREC	;set next record to access.
  3137                    	;
  3138                    	;   For random i/o, set the fcb for the desired record number
  3139                    	; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
  3140                    	; used as follows:
  3141                    	;
  3142                    	;       fcb+35            fcb+34            fcb+33
  3143                    	;  |     'r-2'      |      'r-1'      |      'r-0'     |
  3144                    	;  |7             0 | 7             0 | 7             0|
  3145                    	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
  3146                    	;  |    overflow   | | extra |  extent   |   record #  |
  3147                    	;  | ______________| |_extent|__number___|_____________|
  3148                    	;                     also 's2'
  3149                    	;
  3150                    	;   On entry, register (C) contains 0ffh if this is a read
  3151                    	; and thus we can not access unwritten disk space. Otherwise,
  3152                    	; another extent will be opened (for writing) if required.
  3153                    	;
  3154 F703 AF            	POSITION:XRA	A	;set random i/o flag.
  3155 F704 32 D5 F9      		STA	MODE
  3156                    	;
  3157                    	;   Special entry (function #40). M/PM ?
  3158                    	;
  3159 F707 C5            	POSITN1	PUSH	B	;save read/write flag.
  3160 F708 2A 43 EF      		LHLD	PARAMS	;get address of fcb.
  3161 F70B EB            		XCHG
  3162 F70C 21 21 00      		LXI	H,33	;now get byte 'r0'.
  3163 F70F 19            		DAD	D
  3164 F710 7E            		MOV	A,M
  3165 F711 E6 7F         		ANI	7FH	;keep bits 0-6 for the record number to access.
  3166 F713 F5            		PUSH	PSW
  3167 F714 7E            		MOV	A,M	;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
  3168 F715 17            		RAL
  3169 F716 23            		INX	H
  3170 F717 7E            		MOV	A,M
  3171 F718 17            		RAL
  3172 F719 E6 1F         		ANI	1FH	;and save this in bits 0-4 of (C).
  3173 F71B 4F            		MOV	C,A	;this is the extent byte.
  3174 F71C 7E            		MOV	A,M	;now get the extra extent byte.
  3175 F71D 1F            		RAR
  3176 F71E 1F            		RAR
  3177 F71F 1F            		RAR
  3178 F720 1F            		RAR
  3179 F721 E6 0F         		ANI	0FH
  3180 F723 47            		MOV	B,A	;and save it in (B).
  3181 F724 F1            		POP	PSW	;get record number back to (A).
  3182 F725 23            		INX	H	;check overflow byte 'r2'.
  3183 F726 6E            		MOV	L,M
  3184 F727 2C            		INR	L
  3185 F728 2D            		DCR	L
  3186 F729 2E 06         		MVI	L,6	;prepare for error.
  3187 F72B C2 8B F7      		JNZ	POSITN5	;out of disk space error.
  3188 F72E 21 20 00      		LXI	H,32	;store record number into fcb.
  3189 F731 19            		DAD	D
  3190 F732 77            		MOV	M,A
  3191 F733 21 0C 00      		LXI	H,12	;and now check the extent byte.
  3192 F736 19            		DAD	D
  3193 F737 79            		MOV	A,C
  3194 F738 96            		SUB	M	;same extent as before?
  3195 F739 C2 47 F7      		JNZ	POSITN2
  3196 F73C 21 0E 00      		LXI	H,14	;yes, check extra extent byte 's2' also.
  3197 F73F 19            		DAD	D
  3198 F740 78            		MOV	A,B
  3199 F741 96            		SUB	M
  3200 F742 E6 7F         		ANI	7FH
  3201 F744 CA 7F F7      		JZ	POSITN3;same, we are almost done then.
  3202                    	;
  3203                    	;  Get here when another extent is required.
  3204                    	;
  3205 F747 C5            	POSITN2	PUSH	B
  3206 F748 D5            		PUSH	D
  3207 F749 CD A2 F4      		CALL	CLOSEIT	;close current extent.
  3208 F74C D1            		POP	D
  3209 F74D C1            		POP	B
  3210 F74E 2E 03         		MVI	L,3	;prepare for error.
  3211 F750 3A 45 EF      		LDA	STATUS
  3212 F753 3C            		INR	A
  3213 F754 CA 84 F7      		JZ	POSITN4	;close error.
  3214 F757 21 0C 00      		LXI	H,12	;put desired extent into fcb now.
  3215 F75A 19            		DAD	D
  3216 F75B 71            		MOV	M,C
  3217 F75C 21 0E 00      		LXI	H,14	;and store extra extent byte 's2'.
  3218 F75F 19            		DAD	D
  3219 F760 70            		MOV	M,B
  3220 F761 CD 51 F4      		CALL	OPENIT	;try and get this extent.
  3221 F764 3A 45 EF      		LDA	STATUS	;was it there?
  3222 F767 3C            		INR	A
  3223 F768 C2 7F F7      		JNZ	POSITN3
  3224 F76B C1            		POP	B	;no. can we create a new one (writing?).
  3225 F76C C5            		PUSH	B
  3226 F76D 2E 04         		MVI	L,4	;prepare for error.
  3227 F76F 0C            		INR	C
  3228 F770 CA 84 F7      		JZ	POSITN4	;nope, reading unwritten space error.
  3229 F773 CD 24 F5      		CALL	GETEMPTY;yes we can, try to find space.
  3230 F776 2E 05         		MVI	L,5	;prepare for error.
  3231 F778 3A 45 EF      		LDA	STATUS
  3232 F77B 3C            		INR	A
  3233 F77C CA 84 F7      		JZ	POSITN4	;out of space?
  3234                    	;
  3235                    	;   Normal return location. Clear error code and return.
  3236                    	;
  3237 F77F C1            	POSITN3	POP	B	;restore stack.
  3238 F780 AF            		XRA	A	;and clear error code byte.
  3239 F781 C3 01 EF      		JMP	SETSTAT
  3240                    	;
  3241                    	;   Error. Set the 's2' byte to indicate this (why?).
  3242                    	;
  3243 F784 E5            	POSITN4	PUSH	H
  3244 F785 CD 69 F1      		CALL	GETS2
  3245 F788 36 C0         		MVI	M,0C0H
  3246 F78A E1            		POP	H
  3247                    	;
  3248                    	;   Return with error code (presently in L).
  3249                    	;
  3250 F78B C1            	POSITN5	POP	B
  3251 F78C 7D            		MOV	A,L	;get error code.
  3252 F78D 32 45 EF      		STA	STATUS
  3253 F790 C3 78 F1      		JMP	SETS2B7
  3254                    	;
  3255                    	;   Read a random record.
  3256                    	;
  3257 F793 0E FF         	READRAN	MVI	C,0FFH	;set 'read' status.
  3258 F795 CD 03 F7      		CALL	POSITION;position the file to proper record.
  3259 F798 CC C1 F5      		CZ	RDSEQ1	;and read it as usual (if no errors).
  3260 F79B C9            		RET
  3261                    	;
  3262                    	;   Write to a random record.
  3263                    	;
  3264 F79C 0E 00         	WRITERAN:MVI	C,0	;set 'writing' flag.
  3265 F79E CD 03 F7      		CALL	POSITION;position the file to proper record.
  3266 F7A1 CC 03 F6      		CZ	WTSEQ1	;and write as usual (if no errors).
  3267 F7A4 C9            		RET
  3268                    	;
  3269                    	;   Compute the random record number. Enter with (HL) pointing
  3270                    	; to a fcb an (DE) contains a relative location of a record
  3271                    	; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
  3272                    	; byte, and (A) the 'r2' byte.
  3273                    	;
  3274                    	;   On return, the zero flag is set if the record is within
  3275                    	; bounds. Otherwise, an overflow occured.
  3276                    	;
  3277 F7A5 EB            	COMPRAND:XCHG		;save fcb pointer in (DE).
  3278 F7A6 19            		DAD	D	;compute relative position of record #.
  3279 F7A7 4E            		MOV	C,M	;get record number into (BC).
  3280 F7A8 06 00         		MVI	B,0
  3281 F7AA 21 0C 00      		LXI	H,12	;now get extent.
  3282 F7AD 19            		DAD	D
  3283 F7AE 7E            		MOV	A,M	;compute (BC)=(record #)+(extent)*128.
  3284 F7AF 0F            		RRC		;move lower bit into bit 7.
  3285 F7B0 E6 80         		ANI	80H	;and ignore all other bits.
  3286 F7B2 81            		ADD	C	;add to our record number.
  3287 F7B3 4F            		MOV	C,A
  3288 F7B4 3E 00         		MVI	A,0	;take care of any carry.
  3289 F7B6 88            		ADC	B
  3290 F7B7 47            		MOV	B,A
  3291 F7B8 7E            		MOV	A,M	;now get the upper bits of extent into
  3292 F7B9 0F            		RRC		;bit positions 0-3.
  3293 F7BA E6 0F         		ANI	0FH	;and ignore all others.
  3294 F7BC 80            		ADD	B	;add this in to 'r1' byte.
  3295 F7BD 47            		MOV	B,A
  3296 F7BE 21 0E 00      		LXI	H,14	;get the 's2' byte (extra extent).
  3297 F7C1 19            		DAD	D
  3298 F7C2 7E            		MOV	A,M
  3299 F7C3 87            		ADD	A	;and shift it left 4 bits (bits 4-7).
  3300 F7C4 87            		ADD	A
  3301 F7C5 87            		ADD	A
  3302 F7C6 87            		ADD	A
  3303 F7C7 F5            		PUSH	PSW	;save carry flag (bit 0 of flag byte).
  3304 F7C8 80            		ADD	B	;now add extra extent into 'r1'.
  3305 F7C9 47            		MOV	B,A
  3306 F7CA F5            		PUSH	PSW	;and save carry (overflow byte 'r2').
  3307 F7CB E1            		POP	H	;bit 0 of (L) is the overflow indicator.
  3308 F7CC 7D            		MOV	A,L
  3309 F7CD E1            		POP	H	;and same for first carry flag.
  3310 F7CE B5            		ORA	L	;either one of these set?
  3311 F7CF E6 01         		ANI	01H	;only check the carry flags.
  3312 F7D1 C9            		RET
  3313                    	;
  3314                    	;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
  3315                    	; reflect the last record used for a random (or other) file.
  3316                    	; This reads the directory and looks at all extents computing
  3317                    	; the largerst record number for each and keeping the maximum
  3318                    	; value only. Then 'r0', 'r1', and 'r2' will reflect this
  3319                    	; maximum record number. This is used to compute the space used
  3320                    	; by a random file.
  3321                    	;
  3322 F7D2 0E 0C         	RANSIZE	MVI	C,12	;look thru directory for first entry with
  3323 F7D4 CD 18 F3      		CALL	FINDFST	;this name.
  3324 F7D7 2A 43 EF      		LHLD	PARAMS	;zero out the 'r0, r1, r2' bytes.
  3325 F7DA 11 21 00      		LXI	D,33
  3326 F7DD 19            		DAD	D
  3327 F7DE E5            		PUSH	H
  3328 F7DF 72            		MOV	M,D	;note that (D)=0.
  3329 F7E0 23            		INX	H
  3330 F7E1 72            		MOV	M,D
  3331 F7E2 23            		INX	H
  3332 F7E3 72            		MOV	M,D
  3333 F7E4 CD F5 F1      	RANSIZ1	CALL	CKFILPOS;is there an extent to process?
  3334 F7E7 CA 0C F8      		JZ	RANSIZ3	;no, we are done.
  3335 F7EA CD 5E F1      		CALL	FCB2HL	;set (HL) pointing to proper fcb in dir.
  3336 F7ED 11 0F 00      		LXI	D,15	;point to last record in extent.
  3337 F7F0 CD A5 F7      		CALL	COMPRAND;and compute random parameters.
  3338 F7F3 E1            		POP	H
  3339 F7F4 E5            		PUSH	H	;now check these values against those
  3340 F7F5 5F            		MOV	E,A	;already in fcb.
  3341 F7F6 79            		MOV	A,C	;the carry flag will be set if those
  3342 F7F7 96            		SUB	M	;in the fcb represent a larger size than
  3343 F7F8 23            		INX	H	;this extent does.
  3344 F7F9 78            		MOV	A,B
  3345 F7FA 9E            		SBB	M
  3346 F7FB 23            		INX	H
  3347 F7FC 7B            		MOV	A,E
  3348 F7FD 9E            		SBB	M
  3349 F7FE DA 06 F8      		JC	RANSIZ2
  3350 F801 73            		MOV	M,E	;we found a larger (in size) extent.
  3351 F802 2B            		DCX	H	;stuff these values into fcb.
  3352 F803 70            		MOV	M,B
  3353 F804 2B            		DCX	H
  3354 F805 71            		MOV	M,C
  3355 F806 CD 2D F3      	RANSIZ2	CALL	FINDNXT	;now get the next extent.
  3356 F809 C3 E4 F7      		JMP	RANSIZ1	;continue til all done.
  3357 F80C E1            	RANSIZ3	POP	H	;we are done, restore the stack and
  3358 F80D C9            		RET		;return.
  3359                    	;
  3360                    	;   Function to return the random record position of a given
  3361                    	; file which has been read in sequential mode up to now.
  3362                    	;
  3363 F80E 2A 43 EF      	SETRAN	LHLD	PARAMS	;point to fcb.
  3364 F811 11 20 00      		LXI	D,32	;and to last used record.
  3365 F814 CD A5 F7      		CALL	COMPRAND;compute random position.
  3366 F817 21 21 00      		LXI	H,33	;now stuff these values into fcb.
  3367 F81A 19            		DAD	D
  3368 F81B 71            		MOV	M,C	;move 'r0'.
  3369 F81C 23            		INX	H
  3370 F81D 70            		MOV	M,B	;and 'r1'.
  3371 F81E 23            		INX	H
  3372 F81F 77            		MOV	M,A	;and lastly 'r2'.
  3373 F820 C9            		RET
  3374                    	;
  3375                    	;   This routine select the drive specified in (ACTIVE) and
  3376                    	; update the login vector and bitmap table if this drive was
  3377                    	; not already active.
  3378                    	;
  3379 F821 2A AF F9      	LOGINDRV:LHLD	LOGIN	;get the login vector.
  3380 F824 3A 42 EF      		LDA	ACTIVE	;get the default drive.
  3381 F827 4F            		MOV	C,A
  3382 F828 CD EA F0      		CALL	SHIFTR	;position active bit for this drive
  3383 F82B E5            		PUSH	H	;into bit 0.
  3384 F82C EB            		XCHG
  3385 F82D CD 59 EF      		CALL	SELECT	;select this drive.
  3386 F830 E1            		POP	H
  3387 F831 CC 47 EF      		CZ	SLCTERR	;valid drive?
  3388 F834 7D            		MOV	A,L	;is this a newly activated drive?
  3389 F835 1F            		RAR
  3390 F836 D8            		RC
  3391 F837 2A AF F9      		LHLD	LOGIN	;yes, update the login vector.
  3392 F83A 4D            		MOV	C,L
  3393 F83B 44            		MOV	B,H
  3394 F83C CD 0B F1      		CALL	SETBIT
  3395 F83F 22 AF F9      		SHLD	LOGIN	;and save.
  3396 F842 C3 A3 F2      		JMP	BITMAP	;now update the bitmap.
  3397                    	;
  3398                    	;   Function to set the active disk number.
  3399                    	;
  3400 F845 3A D6 F9      	SETDSK	LDA	EPARAM	;get parameter passed and see if this
  3401 F848 21 42 EF      		LXI	H,ACTIVE;represents a change in drives.
  3402 F84B BE            		CMP	M
  3403 F84C C8            		RZ
  3404 F84D 77            		MOV	M,A	;yes it does, log it in.
  3405 F84E C3 21 F8      		JMP	LOGINDRV
  3406                    	;
  3407                    	;   This is the 'auto disk select' routine. The firsst byte
  3408                    	; of the fcb is examined for a drive specification. If non
  3409                    	; zero then the drive will be selected and loged in.
  3410                    	;
  3411 F851 3E FF         	AUTOSEL	MVI	A,0FFH	;say 'auto-select activated'.
  3412 F853 32 DE F9      		STA	AUTO
  3413 F856 2A 43 EF      		LHLD	PARAMS	;get drive specified.
  3414 F859 7E            		MOV	A,M
  3415 F85A E6 1F         		ANI	1FH	;look at lower 5 bits.
  3416 F85C 3D            		DCR	A	;adjust for (1=A, 2=B) etc.
  3417 F85D 32 D6 F9      		STA	EPARAM	;and save for the select routine.
  3418 F860 FE 1E         		CPI	1EH	;check for 'no change' condition.
  3419 F862 D2 75 F8      		JNC	AUTOSL1	;yes, don't change.
  3420 F865 3A 42 EF      		LDA	ACTIVE	;we must change, save currently active
  3421 F868 32 DF F9      		STA	OLDDRV	;drive.
  3422 F86B 7E            		MOV	A,M	;and save first byte of fcb also.
  3423 F86C 32 E0 F9      		STA	AUTOFLAG;this must be non-zero.
  3424 F86F E6 E0         		ANI	0E0H	;whats this for (bits 6,7 are used for
  3425 F871 77            		MOV	M,A	;something)?
  3426 F872 CD 45 F8      		CALL	SETDSK	;select and log in this drive.
  3427 F875 3A 41 EF      	AUTOSL1	LDA	USERNO	;move user number into fcb.
  3428 F878 2A 43 EF      		LHLD	PARAMS	;(* upper half of first byte *)
  3429 F87B B6            		ORA	M
  3430 F87C 77            		MOV	M,A
  3431 F87D C9            		RET		;and return (all done).
  3432                    	;
  3433                    	;   Function to return the current cp/m version number.
  3434                    	;
  3435 F87E 3E 22         	GETVER	MVI	A,022h	;version 2.2
  3436 F880 C3 01 EF      		JMP	SETSTAT
  3437                    	;
  3438                    	;   Function to reset the disk system.
  3439                    	;
  3440 F883 21 00 00      	RSTDSK	LXI	H,0	;clear write protect status and log
  3441 F886 22 AD F9      		SHLD	WRTPRT	;in vector.
  3442 F889 22 AF F9      		SHLD	LOGIN
  3443 F88C AF            		XRA	A	;select drive 'A'.
  3444 F88D 32 42 EF      		STA	ACTIVE
  3445 F890 21 80 00      		LXI	H,TBUFF	;setup default dma address.
  3446 F893 22 B1 F9      		SHLD	USERDMA
  3447 F896 CD DA F1      		CALL	DEFDMA
  3448 F899 C3 21 F8      		JMP	LOGINDRV;now log in drive 'A'.
  3449                    	;
  3450                    	;   Function to open a specified file.
  3451                    	;
  3452 F89C CD 72 F1      	OPENFIL	CALL	CLEARS2	;clear 's2' byte.
  3453 F89F CD 51 F8      		CALL	AUTOSEL	;select proper disk.
  3454 F8A2 C3 51 F4      		JMP	OPENIT	;and open the file.
  3455                    	;
  3456                    	;   Function to close a specified file.
  3457                    	;
  3458 F8A5 CD 51 F8      	CLOSEFIL:CALL	AUTOSEL	;select proper disk.
  3459 F8A8 C3 A2 F4      		JMP	CLOSEIT	;and close the file.
  3460                    	;
  3461                    	;   Function to return the first occurence of a specified file
  3462                    	; name. If the first byte of the fcb is '?' then the name will
  3463                    	; not be checked (get the first entry no matter what).
  3464                    	;
  3465 F8AB 0E 00         	GETFST	MVI	C,0	;prepare for special search.
  3466 F8AD EB            		XCHG
  3467 F8AE 7E            		MOV	A,M	;is first byte a '?'?
  3468 F8AF FE 3F         		CPI	'?'
  3469 F8B1 CA C2 F8      		JZ	GETFST1	;yes, just get very first entry (zero length match).
  3470 F8B4 CD A6 F0      		CALL	SETEXT	;get the extension byte from fcb.
  3471 F8B7 7E            		MOV	A,M	;is it '?'? if yes, then we want
  3472 F8B8 FE 3F         		CPI	'?'	;an entry with a specific 's2' byte.
  3473 F8BA C4 72 F1      		CNZ	CLEARS2	;otherwise, look for a zero 's2' byte.
  3474 F8BD CD 51 F8      		CALL	AUTOSEL	;select proper drive.
  3475 F8C0 0E 0F         		MVI	C,15	;compare bytes 0-14 in fcb (12&13 excluded).
  3476 F8C2 CD 18 F3      	GETFST1	CALL	FINDFST	;find an entry and then move it into
  3477 F8C5 C3 E9 F1      		JMP	MOVEDIR	;the users dma space.
  3478                    	;
  3479                    	;   Function to return the next occurence of a file name.
  3480                    	;
  3481 F8C8 2A D9 F9      	GETNXT	LHLD	SAVEFCB	;restore pointers. note that no
  3482 F8CB 22 43 EF      		SHLD	PARAMS	;other dbos calls are allowed.
  3483 F8CE CD 51 F8      		CALL	AUTOSEL	;no error will be returned, but the
  3484 F8D1 CD 2D F3      		CALL	FINDNXT	;results will be wrong.
  3485 F8D4 C3 E9 F1      		JMP	MOVEDIR
  3486                    	;
  3487                    	;   Function to delete a file by name.
  3488                    	;
  3489 F8D7 CD 51 F8      	DELFILE	CALL	AUTOSEL	;select proper drive.
  3490 F8DA CD 9C F3      		CALL	ERAFILE	;erase the file.
  3491 F8DD C3 01 F3      		JMP	STSTATUS;set status and return.
  3492                    	;
  3493                    	;   Function to execute a sequential read of the specified
  3494                    	; record number.
  3495                    	;
  3496 F8E0 CD 51 F8      	READSEQ	CALL	AUTOSEL	;select proper drive then read.
  3497 F8E3 C3 BC F5      		JMP	RDSEQ
  3498                    	;
  3499                    	;   Function to write the net sequential record.
  3500                    	;
  3501 F8E6 CD 51 F8      	WRTSEQ	CALL	AUTOSEL	;select proper drive then write.
  3502 F8E9 C3 FE F5      		JMP	WTSEQ
  3503                    	;
  3504                    	;   Create a file function.
  3505                    	;
  3506 F8EC CD 72 F1      	FCREATE	CALL	CLEARS2	;clear the 's2' byte on all creates.
  3507 F8EF CD 51 F8      		CALL	AUTOSEL	;select proper drive and get the next
  3508 F8F2 C3 24 F5      		JMP	GETEMPTY;empty directory space.
  3509                    	;
  3510                    	;   Function to rename a file.
  3511                    	;
  3512 F8F5 CD 51 F8      	RENFILE	CALL	AUTOSEL	;select proper drive and then switch
  3513 F8F8 CD 16 F4      		CALL	CHGNAMES;file names.
  3514 F8FB C3 01 F3      		JMP	STSTATUS
  3515                    	;
  3516                    	;   Function to return the login vector.
  3517                    	;
  3518 F8FE 2A AF F9      	GETLOG	LHLD	LOGIN
  3519 F901 C3 29 F9      		JMP	GETPRM1
  3520                    	;
  3521                    	;   Function to return the current disk assignment.
  3522                    	;
  3523 F904 3A 42 EF      	GETCRNT	LDA	ACTIVE
  3524 F907 C3 01 EF      		JMP	SETSTAT
  3525                    	;
  3526                    	;   Function to set the dma address.
  3527                    	;
  3528 F90A EB            	PUTDMA	XCHG
  3529 F90B 22 B1 F9      		SHLD	USERDMA	;save in our space and then get to
  3530 F90E C3 DA F1      		JMP	DEFDMA	;the bios with this also.
  3531                    	;
  3532                    	;   Function to return the allocation vector.
  3533                    	;
  3534 F911 2A BF F9      	GETALOC	LHLD	ALOCVECT
  3535 F914 C3 29 F9      		JMP	GETPRM1
  3536                    	;
  3537                    	;   Function to return the read-only status vector.
  3538                    	;
  3539 F917 2A AD F9      	GETROV	LHLD	WRTPRT
  3540 F91A C3 29 F9      		JMP	GETPRM1
  3541                    	;
  3542                    	;   Function to set the file attributes (read-only, system).
  3543                    	;
  3544 F91D CD 51 F8      	SETATTR	CALL	AUTOSEL	;select proper drive then save attributes.
  3545 F920 CD 3B F4      		CALL	SAVEATTR
  3546 F923 C3 01 F3      		JMP	STSTATUS
  3547                    	;
  3548                    	;   Function to return the address of the disk parameter block
  3549                    	; for the current drive.
  3550                    	;
  3551 F926 2A BB F9      	GETPARM	LHLD	DISKPB
  3552 F929 22 45 EF      	GETPRM1	SHLD	STATUS
  3553 F92C C9            		RET
  3554                    	;
  3555                    	;   Function to get or set the user number. If (E) was (FF)
  3556                    	; then this is a request to return the current user number.
  3557                    	; Else set the user number from (E).
  3558                    	;
  3559 F92D 3A D6 F9      	GETUSER	LDA	EPARAM	;get parameter.
  3560 F930 FE FF         		CPI	0FFH	;get user number?
  3561 F932 C2 3B F9      		JNZ	SETUSER
  3562 F935 3A 41 EF      		LDA	USERNO	;yes, just do it.
  3563 F938 C3 01 EF      		JMP	SETSTAT
  3564 F93B E6 1F         	SETUSER	ANI	1FH	;no, we should set it instead. keep low
  3565 F93D 32 41 EF      		STA	USERNO	;bits (0-4) only.
  3566 F940 C9            		RET
  3567                    	;
  3568                    	;   Function to read a random record from a file.
  3569                    	;
  3570 F941 CD 51 F8      	RDRANDOM:CALL	AUTOSEL	;select proper drive and read.
  3571 F944 C3 93 F7      		JMP	READRAN
  3572                    	;
  3573                    	;   Function to compute the file size for random files.
  3574                    	;
  3575 F947 CD 51 F8      	WTRANDOM:CALL	AUTOSEL	;select proper drive and write.
  3576 F94A C3 9C F7      		JMP	WRITERAN
  3577                    	;
  3578                    	;   Function to compute the size of a random file.
  3579                    	;
  3580 F94D CD 51 F8      	FILESIZE:CALL	AUTOSEL	;select proper drive and check file length
  3581 F950 C3 D2 F7      		JMP	RANSIZE
  3582                    	;
  3583                    	;   Function #37. This allows a program to log off any drives.
  3584                    	; On entry, set (DE) to contain a word with bits set for those
  3585                    	; drives that are to be logged off. The log-in vector and the
  3586                    	; write protect vector will be updated. This must be a M/PM
  3587                    	; special function.
  3588                    	;
  3589 F953 2A 43 EF      	LOGOFF	LHLD	PARAMS	;get drives to log off.
  3590 F956 7D            		MOV	A,L	;for each bit that is set, we want
  3591 F957 2F            		CMA		;to clear that bit in (LOGIN)
  3592 F958 5F            		MOV	E,A	;and (WRTPRT).
  3593 F959 7C            		MOV	A,H
  3594 F95A 2F            		CMA
  3595 F95B 2A AF F9      		LHLD	LOGIN	;reset the login vector.
  3596 F95E A4            		ANA	H
  3597 F95F 57            		MOV	D,A
  3598 F960 7D            		MOV	A,L
  3599 F961 A3            		ANA	E
  3600 F962 5F            		MOV	E,A
  3601 F963 2A AD F9      		LHLD	WRTPRT
  3602 F966 EB            		XCHG
  3603 F967 22 AF F9      		SHLD	LOGIN	;and save.
  3604 F96A 7D            		MOV	A,L	;now do the write protect vector.
  3605 F96B A3            		ANA	E
  3606 F96C 6F            		MOV	L,A
  3607 F96D 7C            		MOV	A,H
  3608 F96E A2            		ANA	D
  3609 F96F 67            		MOV	H,A
  3610 F970 22 AD F9      		SHLD	WRTPRT	;and save. all done.
  3611 F973 C9            		RET
  3612                    	;
  3613                    	;   Get here to return to the user.
  3614                    	;
  3615 F974 3A DE F9      	GOBACK	LDA	AUTO	;was auto select activated?
  3616 F977 B7            		ORA	A
  3617 F978 CA 91 F9      		JZ	GOBACK1
  3618 F97B 2A 43 EF      		LHLD	PARAMS	;yes, but was a change made?
  3619 F97E 36 00         		MVI	M,0	;(* reset first byte of fcb *)
  3620 F980 3A E0 F9      		LDA	AUTOFLAG
  3621 F983 B7            		ORA	A
  3622 F984 CA 91 F9      		JZ	GOBACK1
  3623 F987 77            		MOV	M,A	;yes, reset first byte properly.
  3624 F988 3A DF F9      		LDA	OLDDRV	;and get the old drive and select it.
  3625 F98B 32 D6 F9      		STA	EPARAM
  3626 F98E CD 45 F8      		CALL	SETDSK
  3627 F991 2A 0F EF      	GOBACK1	LHLD	USRSTACK;reset the users stack pointer.
  3628 F994 F9            		SPHL
  3629 F995 2A 45 EF      		LHLD	STATUS	;get return status.
  3630 F998 7D            		MOV	A,L	;force version 1.4 compatability.
  3631 F999 44            		MOV	B,H
  3632 F99A C9            		RET		;and go back to user.
  3633                    	;
  3634                    	;   Function #40. This is a special entry to do random i/o.
  3635                    	; For the case where we are writing to unused disk space, this
  3636                    	; space will be zeroed out first. This must be a M/PM special
  3637                    	; purpose function, because why would any normal program even
  3638                    	; care about the previous contents of a sector about to be
  3639                    	; written over.
  3640                    	;
  3641 F99B CD 51 F8      	WTSPECL	CALL	AUTOSEL	;select proper drive.
  3642 F99E 3E 02         		MVI	A,2	;use special write mode.
  3643 F9A0 32 D5 F9      		STA	MODE
  3644 F9A3 0E 00         		MVI	C,0	;set write indicator.
  3645 F9A5 CD 07 F7      		CALL	POSITN1	;position the file.
  3646 F9A8 CC 03 F6      		CZ	WTSEQ1	;and write (if no errors).
  3647 F9AB C9            		RET
  3648                    	;
  3649                    	;**************************************************************
  3650                    	;*
  3651                    	;*     BDOS data storage pool.
  3652                    	;*
  3653                    	;**************************************************************
  3654                    	;
  3655 F9AC               	EMPTYFCB:DB	0E5H	;empty directory segment indicator.
            E5 
  3656 F9AD               	WRTPRT	DW	0	;write protect status for all 16 drives.
            00 00 
  3657 F9AF               	LOGIN	DW	0	;drive active word (1 bit per drive).
            00 00 
  3658 F9B1               	USERDMA	DW	080H	;user's dma address (defaults to 80h).
            80 00 
  3659                    	;
  3660                    	;   Scratch areas from parameter block.
  3661                    	;
  3662 F9B3               	SCRATCH1:DW	0	;relative position within dir segment for file (0-3).
            00 00 
  3663 F9B5               	SCRATCH2:DW	0	;last selected track number.
            00 00 
  3664 F9B7               	SCRATCH3:DW	0	;last selected sector number.
            00 00 
  3665                    	;
  3666                    	;   Disk storage areas from parameter block.
  3667                    	;
  3668 F9B9               	DIRBUF	DW	0	;address of directory buffer to use.
            00 00 
  3669 F9BB               	DISKPB	DW	0	;contains address of disk parameter block.
            00 00 
  3670 F9BD               	CHKVECT	DW	0	;address of check vector.
            00 00 
  3671 F9BF               	ALOCVECT:DW	0	;address of allocation vector (bit map).
            00 00 
  3672                    	;
  3673                    	;   Parameter block returned from the bios.
  3674                    	;
  3675 F9C1               	SECTORS	DW	0	;sectors per track from bios.
            00 00 
  3676 F9C3               	BLKSHFT	DB	0	;block shift.
            00 
  3677 F9C4               	BLKMASK	DB	0	;block mask.
            00 
  3678 F9C5               	EXTMASK	DB	0	;extent mask.
            00 
  3679 F9C6               	DSKSIZE	DW	0	;disk size from bios (number of blocks-1).
            00 00 
  3680 F9C8               	DIRSIZE	DW	0	;directory size.
            00 00 
  3681 F9CA               	ALLOC0	DW	0	;storage for first bytes of bit map (dir space used).
            00 00 
  3682 F9CC               	ALLOC1	DW	0
            00 00 
  3683 F9CE               	OFFSET	DW	0	;first usable track number.
            00 00 
  3684 F9D0               	XLATE	DW	0	;sector translation table address.
            00 00 
  3685                    	;
  3686                    	;
  3687 F9D2               	CLOSEFLG:DB	0	;close flag (=0ffh is extent written ok).
            00 
  3688 F9D3               	RDWRTFLG:DB	0	;read/write flag (0ffh=read, 0=write).
            00 
  3689 F9D4               	FNDSTAT	DB	0	;filename found status (0=found first entry).
            00 
  3690 F9D5               	MODE	DB	0	;I/o mode select (0=random, 1=sequential, 2=special random).
            00 
  3691 F9D6               	EPARAM	DB	0	;storage for register (E) on entry to bdos.
            00 
  3692 F9D7               	RELBLOCK:DB	0	;relative position within fcb of block number written.
            00 
  3693 F9D8               	COUNTER	DB	0	;byte counter for directory name searches.
            00 
  3694 F9D9               	SAVEFCB	DW	0,0	;save space for address of fcb (for directory searches).
            00 00 00 00 
  3695 F9DD               	BIGDISK	DB	0	;if =0 then disk is > 256 blocks long.
            00 
  3696 F9DE               	AUTO	DB	0	;if non-zero, then auto select activated.
            00 
  3697 F9DF               	OLDDRV	DB	0	;on auto select, storage for previous drive.
            00 
  3698 F9E0               	AUTOFLAG:DB	0	;if non-zero, then auto select changed drives.
            00 
  3699 F9E1               	SAVNXT	DB	0	;storage for next record number to access.
            00 
  3700 F9E2               	SAVEXT	DB	0	;storage for extent number of file.
            00 
  3701 F9E3               	SAVNREC	DW	0	;storage for number of records in file.
            00 00 
  3702 F9E5               	BLKNMBR	DW	0	;block number (physical sector) used within a file or logical sector.
            00 00 
  3703 F9E7               	LOGSECT	DW	0	;starting logical (128 byte) sector of block (physical sector).
            00 00 
  3704 F9E9               	FCBPOS	DB	0	;relative position within buffer for fcb of file of interest.
            00 
  3705 F9EA               	FILEPOS	DW	0	;files position within directory (0 to max entries -1).
            00 00 
  3706                    	;
  3707                    	;   Disk directory buffer checksum bytes. One for each of the
  3708                    	; 16 possible drives.
  3709                    	;
  3710 F9EC               	CKSUMTBL:DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
            00 00 00 00 
  3711                    	;
  3712                    	;   Extra space ?
  3713                    	;
  3714 F9FC               		DB	0,0,0,0
            00 00 00 00 
  3715                    	;
  3716                    	;**************************************************************
  3717                    	;*
  3718                    	;*        B I O S   J U M P   T A B L E
  3719                    	;*
  3720                    	;**************************************************************
  3721                    	;
  3722 FA00 C3 00 00      	BOOT	JMP	0	;NOTE WE USE FAKE DESTINATIONS
  3723 FA03 C3 00 00      	WBOOT	JMP	0
  3724 FA06 C3 00 00      	CONST	JMP	0
  3725 FA09 C3 00 00      	CONIN	JMP	0
  3726 FA0C C3 00 00      	CONOUT	JMP	0
  3727 FA0F C3 00 00      	LIST	JMP	0
  3728 FA12 C3 00 00      	PUNCH	JMP	0
  3729 FA15 C3 00 00      	READER	JMP	0
  3730 FA18 C3 00 00      	HOME	JMP	0
  3731 FA1B C3 00 00      	SELDSK	JMP	0
  3732 FA1E C3 00 00      	SETTRK	JMP	0
  3733 FA21 C3 00 00      	SETSEC	JMP	0
  3734 FA24 C3 00 00      	SETDMA	JMP	0
  3735 FA27 C3 00 00      	READ	JMP	0
  3736 FA2A C3 00 00      	WRITE	JMP	0
  3737 FA2D C3 00 00      	PRSTAT	JMP	0
  3738 FA30 C3 00 00      	SECTRN	JMP	0
  3739                    	;
  3740                    	;*
  3741                    	;******************   E N D   O F   C P / M   *****************
  3742                    	;*
  3743                    	
  3744                    	; vim: syntax=asm ts=8 columns=100 lines=45 
